C51 COMPILER V9.52.0.0   IMU                                                               09/10/2017 12:03:10 PAGE 1   


C51 COMPILER V9.52.0.0, COMPILATION OF MODULE IMU
OBJECT MODULE PLACED IN IMU.OBJ
COMPILER INVOKED BY: D:\c51v952\C51\BIN\C51.EXE IMU.c LARGE BROWSE DEBUG OBJECTEXTEND TABS(2)

line level    source

   1          #include <IMU.h>
   2          #include <math.h>
   3          
   4          
   5          
   6          
   7          #define pi 3.14159265f                           
   8          #define Kp 10.0f                        /////0.8f
   9          #define Ki 0.001f                         
  10          #define halfT 0.004f           
  11          float idata exInt=0,eyInt=0,ezInt=0; 
  12          float idata accel_x,accel_y,accel_z,gyro_x,gyro_y,gyro_z;
  13          float idata Angle_ax,Angle_ay,Angle_az,Angle_gx,Angle_gy,Angle_gz;
  14          float idata q0=1,q1=0,q2=0,q3=0;
  15          float idata pitch,roll,yaw,pitch0,roll0,yaw0;
  16          
  17          /**************取三个数中的中间的一个数值******************/
  18          float medium(float i,float j,float k)
  19          {
  20   1        float tmp;
  21   1        if(i>j)
  22   1        {
  23   2          tmp=i;i=j;j=tmp;
  24   2         }
  25   1         if(k>j)
  26   1           tmp=j;
  27   1         else if (k>i)
  28   1           tmp=k;
  29   1         else 
  30   1           tmp=i;
  31   1         return tmp;
  32   1      }
  33          /**********转化正负*****////
  34          float tranlate(unsigned char char1,unsigned char char2) 
  35          {
  36   1        float aa;
  37   1             if((char1*256+char2)>=32768) aa=(float)((char1*256+char2)-65536);
  38   1                      else  aa= (float)(char1*256+char2);
  39   1        return aa;
  40   1      }
  41          
  42          /**********合成数据  有正负号********/
  43          void dataadd()
  44          {
  45   1        accel_x=tranlate(BUF[0],BUF[1]) ;
  46   1        accel_y=tranlate(BUF[2],BUF[3]) ;
  47   1        accel_z=tranlate(BUF[4],BUF[5]) ;
  48   1        gyro_x=tranlate(BUF[8],BUF[9]) ;
  49   1        gyro_y=tranlate(BUF[10],BUF[11]) ;
  50   1        gyro_z=tranlate(BUF[12],BUF[13]) ;
  51   1      }
  52          /****************滤波1**************/
  53          void smoothing1()
  54          {
  55   1        float idata axa,aya,aza,gxg,gyg,gzg,
C51 COMPILER V9.52.0.0   IMU                                                               09/10/2017 12:03:10 PAGE 2   

  56   1                    xax,yay,zaz,xgx,ygy,zgz;   //取三组数据中的中间的数据
  57   1        read_MPU6050();
  58   1        dataadd();
  59   1        axa=accel_x;
  60   1        aya=accel_y;
  61   1        aza=accel_z;
  62   1        gxg=gyro_x;
  63   1        gyg=gyro_y;
  64   1        gzg=gyro_z;
  65   1        read_MPU6050();
  66   1        dataadd();
  67   1        xax=accel_x;
  68   1        yay=accel_y;
  69   1        zaz=accel_z;
  70   1        xgx=gyro_x;
  71   1        ygy=gyro_y;
  72   1        zgz=gyro_z;
  73   1        read_MPU6050();
  74   1        dataadd();
  75   1        accel_x=medium(axa,xax,accel_x);
  76   1        accel_y=medium(aya,yay,accel_y);
  77   1        accel_z=medium(aza,zaz,accel_z);
  78   1        gyro_x=medium(gxg,xgx,gyro_x);
  79   1        gyro_y=medium(gyg,ygy,gyro_y);
  80   1        gyro_z=medium(gzg,zgz,gyro_z);
  81   1      }
  82          
  83          
  84          /*******************处理原始数据*******************/
  85          void dealdata()
  86          {
  87   1      
  88   1        
  89   1        Angle_ax=accel_x/8192;
  90   1        Angle_ay=accel_y/8192;
  91   1        Angle_az=accel_z/8192;
  92   1        
  93   1        Angle_gx=gyro_x/65.5;
  94   1        Angle_gy=gyro_y/65.5;
  95   1        Angle_gz=gyro_z/65.5;
  96   1        
  97   1        
  98   1        Angle_ax=Angle_ax*pi/180.0;
  99   1        Angle_ay=Angle_ay*pi/180.0;
 100   1        Angle_az=Angle_az*pi/180.0;
 101   1        Angle_gx=Angle_gx*pi/180.0;
 102   1        Angle_gy=Angle_gy*pi/180.0;
 103   1        Angle_gz=Angle_gz*pi/180.0;
 104   1      }
 105          
 106          
 107          
 108          
 109          
 110          /********************计算角度*****************/
 111            void IMUupdate(float gx, float gy, float gz, float ax, float ay, float az)
 112          {
 113   1        float idata norm;
 114   1        float idata vx, vy, vz;
 115   1        float idata ex, ey, ez;
 116   1      
 117   1        float idata q0q0 = q0*q0;
C51 COMPILER V9.52.0.0   IMU                                                               09/10/2017 12:03:10 PAGE 3   

 118   1        float idata q0q1 = q0*q1;
 119   1        float idata q0q2 = q0*q2;
 120   1        float idata q0q3 = q0*q3;
 121   1        float idata q1q1 = q1*q1;
 122   1        float idata q1q2 = q1*q2;
 123   1        float idata q1q3 = q1*q3;
 124   1        float idata q2q2 = q2*q2;
 125   1        float idata q2q3 = q2*q3;
 126   1        float idata q3q3 = q3*q3;
 127   1      
 128   1        norm = sqrt(ax*ax + ay*ay + az*az);      
 129   1        ax = ax /norm;
 130   1        ay = ay / norm;
 131   1        az = az / norm;
 132   1                 
 133   1        vx = 2*(q1q3 - q0q2);                       
 134   1        vy = 2*(q0q1 + q2q3);
 135   1        vz = q0q0 - q1q1 - q2q2 + q3q3 ;
 136   1      
 137   1        ex = (ay*vz - az*vy) ;                                    
 138   1        ey = (az*vx - ax*vz) ;
 139   1        ez = (ax*vy - ay*vx) ;
 140   1      
 141   1        exInt = exInt + ex * Ki;                 
 142   1        eyInt = eyInt + ey * Ki;
 143   1        ezInt = ezInt + ez * Ki;
 144   1      
 145   1        gx = gx + Kp*ex + exInt;                          
 146   1        gy = gy + Kp*ey + eyInt;
 147   1        gz = gz + Kp*ez + ezInt;                        
 148   1                   
 149   1        q0 = q0 + (-q1*gx - q2*gy - q3*gz)*halfT;
 150   1        q1 = q1 + (q0*gx + q2*gz - q3*gy)*halfT;
 151   1        q2 = q2 + (q0*gy - q1*gz + q3*gx)*halfT;
 152   1        q3 = q3 + (q0*gz + q1*gy - q2*gx)*halfT;
 153   1      
 154   1        norm = sqrt(q0*q0 + q1*q1 + q2*q2 + q3*q3);
 155   1        q0 = q0 / norm;
 156   1        q1 = q1 / norm;
 157   1        q2 = q2 / norm;
 158   1        q3 = q3 / norm;
 159   1      
 160   1        pitch=asin(2*(q0*q2-q1*q3 ))* 57.2957795f; // 俯仰
 161   1        roll=-asin(2*(q0*q1+q2*q3 ))* 57.2957795f; // 横滚
 162   1        yaw=-asin(2*(q1*q2+q0*q3))*57.2957795f;  //航向
 163   1      //  pitch=pitch-pitch0;
 164   1        //roll=roll-roll0;
 165   1      //  yaw=yaw-yaw0;
 166   1      }
 167          
 168          //void database(void)
 169          //{
 170          //  smoothing1();
 171          //  
 172          //  
 173          //  
 174          //}


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =   3054    ----
   CONSTANT SIZE    =   ----    ----
C51 COMPILER V9.52.0.0   IMU                                                               09/10/2017 12:03:10 PAGE 4   

   XDATA SIZE       =   ----      46
   PDATA SIZE       =   ----    ----
   DATA SIZE        =   ----    ----
   IDATA SIZE       =    100     116
   BIT SIZE         =   ----    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
