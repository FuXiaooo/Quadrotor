C51 COMPILER V9.52.0.0   51MPU6050DMP                                                      08/28/2017 09:30:04 PAGE 1   


C51 COMPILER V9.52.0.0, COMPILATION OF MODULE 51MPU6050DMP
OBJECT MODULE PLACED IN 51mpu6050DMP.OBJ
COMPILER INVOKED BY: D:\c51v952\C51\BIN\C51.EXE 51mpu6050DMP.c BROWSE DEBUG OBJECTEXTEND TABS(2)

line level    source

   1          /***************************************************** 
   2              功能: 采集MPU6050 DMP 数据 
   3              CPU:    STC89C54RD+ 
   4              晶震: 11.0592 
   5              环境: Keli2.0 
   6              语言: c 
   7              作者：XW1005 
   8              来源：移植 Jeff Jrowberg 公开的程序。 
   9              目的： 
  10          sda 或则scl 为高时是:释放总线 
  11          *****************************************************/  
  12          #include <STC15Fxxxx.h>  
  13          #include <intrins.h>  
  14          bit ack;    //应答标志位 0:ack 1：nak  
  15          sbit scl = P0^0;  
  16          sbit sda = P4^6;  
  17          unsigned char dmpdatas[42]; //DMP数据  
  18          #define SlaveAddress    0xD0    //IIC写入时的地址字节数据，+1为读取  
  19          //#define SlaveAddress 0xae //i2c测试地址  
  20          void SendByte(unsigned char dat);  
  21          unsigned char i2cread(unsigned char addr,unsigned char *Data);  
  22          unsigned char i2creads(unsigned char addr,unsigned char length,unsigned char *Data);  
  23          //以下的 firmware 及 config update 数据来自于 Jeff Jrowberg 公开的程序  
  24          code unsigned char dmpmemorydata[1929]={  
  25           // bank 0, 256 bytes  
  26              0xFB, 0x00, 0x00, 0x3E, 0x00, 0x0B, 0x00, 0x36, 0x00, 0x01, 0x00, 0x02, 0x00, 0x03, 0x00, 0x00,  
  27              0x00, 0x65, 0x00, 0x54, 0xFF, 0xEF, 0x00, 0x00, 0xFA, 0x80, 0x00, 0x0B, 0x12, 0x82, 0x00, 0x01,  
  28              0x00, 0x02, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,  
  29              0x00, 0x28, 0x00, 0x00, 0xFF, 0xFF, 0x45, 0x81, 0xFF, 0xFF, 0xFA, 0x72, 0x00, 0x00, 0x00, 0x00,  
  30              0x00, 0x00, 0x03, 0xE8, 0x00, 0x00, 0x00, 0x01, 0x00, 0x01, 0x7F, 0xFF, 0xFF, 0xFE, 0x80, 0x01,  
  31              0x00, 0x1B, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,  
  32              0x00, 0x3E, 0x03, 0x30, 0x40, 0x00, 0x00, 0x00, 0x02, 0xCA, 0xE3, 0x09, 0x3E, 0x80, 0x00, 0x00,  
  33              0x20, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x40, 0x00, 0x00, 0x00, 0x60, 0x00, 0x00, 0x00,  
  34              0x41, 0xFF, 0x00, 0x00, 0x00, 0x00, 0x0B, 0x2A, 0x00, 0x00, 0x16, 0x55, 0x00, 0x00, 0x21, 0x82,  
  35              0xFD, 0x87, 0x26, 0x50, 0xFD, 0x80, 0x00, 0x00, 0x00, 0x1F, 0x00, 0x00, 0x00, 0x05, 0x80, 0x00,  
  36              0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x02, 0x00, 0x00, 0x00, 0x03, 0x00, 0x00,  
  37              0x40, 0x00, 0x00, 0x00, 0x00, 0x00, 0x04, 0x6F, 0x00, 0x02, 0x65, 0x32, 0x00, 0x00, 0x5E, 0xC0,  
  38              0x40, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,  
  39              0xFB, 0x8C, 0x6F, 0x5D, 0xFD, 0x5D, 0x08, 0xD9, 0x00, 0x7C, 0x73, 0x3B, 0x00, 0x6C, 0x12, 0xCC,  
  40              0x32, 0x00, 0x13, 0x9D, 0x32, 0x00, 0xD0, 0xD6, 0x32, 0x00, 0x08, 0x00, 0x40, 0x00, 0x01, 0xF4,  
  41              0xFF, 0xE6, 0x80, 0x79, 0x02, 0x00, 0x00, 0x00, 0x00, 0x00, 0xD0, 0xD6, 0x00, 0x00, 0x27, 0x10,  
  42              // bank 1, 256 bytes  
  43              0xFB, 0x00, 0x00, 0x00, 0x40, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,  
  44              0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 0x01, 0x00, 0x00, 0x00,  
  45              0x00, 0x00, 0xFA, 0x36, 0xFF, 0xBC, 0x30, 0x8E, 0x00, 0x05, 0xFB, 0xF0, 0xFF, 0xD9, 0x5B, 0xC8,  
  46              0xFF, 0xD0, 0x9A, 0xBE, 0x00, 0x00, 0x10, 0xA9, 0xFF, 0xF4, 0x1E, 0xB2, 0x00, 0xCE, 0xBB, 0xF7,  
  47              0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x04, 0x00, 0x02, 0x00, 0x02, 0x02, 0x00, 0x00, 0x0C,  
  48              0xFF, 0xC2, 0x80, 0x00, 0x00, 0x01, 0x80, 0x00, 0x00, 0xCF, 0x80, 0x00, 0x40, 0x00, 0x00, 0x00,  
  49              0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x06, 0x00, 0x00, 0x00, 0x00, 0x14,  
  50              0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,  
  51              0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,  
  52              0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,  
  53              0x00, 0x00, 0x00, 0x00, 0x03, 0x3F, 0x68, 0xB6, 0x79, 0x35, 0x28, 0xBC, 0xC6, 0x7E, 0xD1, 0x6C,  
  54              0x80, 0x00, 0x00, 0x00, 0x40, 0x00, 0x00, 0x00, 0x00, 0x00, 0xB2, 0x6A, 0x00, 0x00, 0x00, 0x00,  
  55              0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x3F, 0xF0, 0x00, 0x00, 0x00, 0x30,  
C51 COMPILER V9.52.0.0   51MPU6050DMP                                                      08/28/2017 09:30:04 PAGE 2   

  56              0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,  
  57              0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,  
  58              0x00, 0x00, 0x25, 0x4D, 0x00, 0x2F, 0x70, 0x6D, 0x00, 0x00, 0x05, 0xAE, 0x00, 0x0C, 0x02, 0xD0,  
  59              // bank 2, 256 bytes  
  60              0x00, 0x00, 0x00, 0x00, 0x00, 0x65, 0x00, 0x54, 0xFF, 0xEF, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,  
  61              0x00, 0x00, 0x01, 0x00, 0x00, 0x44, 0x00, 0x00, 0x00, 0x00, 0x0C, 0x00, 0x00, 0x00, 0x01, 0x00,  
  62              0x00, 0x00, 0x00, 0x00, 0x00, 0x65, 0x00, 0x00, 0x00, 0x54, 0x00, 0x00, 0xFF, 0xEF, 0x00, 0x00,  
  63              0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,  
  64              0x40, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,  
  65              0x40, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,  
  66              0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x02, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,  
  67              0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,  
  68              0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,  
  69              0x00, 0x1B, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,  
  70              0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,  
  71              0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x40, 0x00, 0x00, 0x00,  
  72              0x00, 0x1B, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,  
  73              0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,  
  74              0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,  
  75              0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,  
  76              // bank 3, 256 bytes  
  77              0xD8, 0xDC, 0xBA, 0xA2, 0xF1, 0xDE, 0xB2, 0xB8, 0xB4, 0xA8, 0x81, 0x91, 0xF7, 0x4A, 0x90, 0x7F,  
  78              0x91, 0x6A, 0xF3, 0xF9, 0xDB, 0xA8, 0xF9, 0xB0, 0xBA, 0xA0, 0x80, 0xF2, 0xCE, 0x81, 0xF3, 0xC2,  
  79              0xF1, 0xC1, 0xF2, 0xC3, 0xF3, 0xCC, 0xA2, 0xB2, 0x80, 0xF1, 0xC6, 0xD8, 0x80, 0xBA, 0xA7, 0xDF,  
  80              0xDF, 0xDF, 0xF2, 0xA7, 0xC3, 0xCB, 0xC5, 0xB6, 0xF0, 0x87, 0xA2, 0x94, 0x24, 0x48, 0x70, 0x3C,  
  81              0x95, 0x40, 0x68, 0x34, 0x58, 0x9B, 0x78, 0xA2, 0xF1, 0x83, 0x92, 0x2D, 0x55, 0x7D, 0xD8, 0xB1,  
  82              0xB4, 0xB8, 0xA1, 0xD0, 0x91, 0x80, 0xF2, 0x70, 0xF3, 0x70, 0xF2, 0x7C, 0x80, 0xA8, 0xF1, 0x01,  
  83              0xB0, 0x98, 0x87, 0xD9, 0x43, 0xD8, 0x86, 0xC9, 0x88, 0xBA, 0xA1, 0xF2, 0x0E, 0xB8, 0x97, 0x80,  
  84              0xF1, 0xA9, 0xDF, 0xDF, 0xDF, 0xAA, 0xDF, 0xDF, 0xDF, 0xF2, 0xAA, 0xC5, 0xCD, 0xC7, 0xA9, 0x0C,  
  85              0xC9, 0x2C, 0x97, 0x97, 0x97, 0x97, 0xF1, 0xA9, 0x89, 0x26, 0x46, 0x66, 0xB0, 0xB4, 0xBA, 0x80,  
  86              0xAC, 0xDE, 0xF2, 0xCA, 0xF1, 0xB2, 0x8C, 0x02, 0xA9, 0xB6, 0x98, 0x00, 0x89, 0x0E, 0x16, 0x1E,  
  87              0xB8, 0xA9, 0xB4, 0x99, 0x2C, 0x54, 0x7C, 0xB0, 0x8A, 0xA8, 0x96, 0x36, 0x56, 0x76, 0xF1, 0xB9,  
  88              0xAF, 0xB4, 0xB0, 0x83, 0xC0, 0xB8, 0xA8, 0x97, 0x11, 0xB1, 0x8F, 0x98, 0xB9, 0xAF, 0xF0, 0x24,  
  89              0x08, 0x44, 0x10, 0x64, 0x18, 0xF1, 0xA3, 0x29, 0x55, 0x7D, 0xAF, 0x83, 0xB5, 0x93, 0xAF, 0xF0,  
  90              0x00, 0x28, 0x50, 0xF1, 0xA3, 0x86, 0x9F, 0x61, 0xA6, 0xDA, 0xDE, 0xDF, 0xD9, 0xFA, 0xA3, 0x86,  
  91              0x96, 0xDB, 0x31, 0xA6, 0xD9, 0xF8, 0xDF, 0xBA, 0xA6, 0x8F, 0xC2, 0xC5, 0xC7, 0xB2, 0x8C, 0xC1,  
  92              0xB8, 0xA2, 0xDF, 0xDF, 0xDF, 0xA3, 0xDF, 0xDF, 0xDF, 0xD8, 0xD8, 0xF1, 0xB8, 0xA8, 0xB2, 0x86,  
  93              // bank 4, 256 bytes  
  94              0xB4, 0x98, 0x0D, 0x35, 0x5D, 0xB8, 0xAA, 0x98, 0xB0, 0x87, 0x2D, 0x35, 0x3D, 0xB2, 0xB6, 0xBA,  
  95              0xAF, 0x8C, 0x96, 0x19, 0x8F, 0x9F, 0xA7, 0x0E, 0x16, 0x1E, 0xB4, 0x9A, 0xB8, 0xAA, 0x87, 0x2C,  
  96              0x54, 0x7C, 0xB9, 0xA3, 0xDE, 0xDF, 0xDF, 0xA3, 0xB1, 0x80, 0xF2, 0xC4, 0xCD, 0xC9, 0xF1, 0xB8,  
  97              0xA9, 0xB4, 0x99, 0x83, 0x0D, 0x35, 0x5D, 0x89, 0xB9, 0xA3, 0x2D, 0x55, 0x7D, 0xB5, 0x93, 0xA3,  
  98              0x0E, 0x16, 0x1E, 0xA9, 0x2C, 0x54, 0x7C, 0xB8, 0xB4, 0xB0, 0xF1, 0x97, 0x83, 0xA8, 0x11, 0x84,  
  99              0xA5, 0x09, 0x98, 0xA3, 0x83, 0xF0, 0xDA, 0x24, 0x08, 0x44, 0x10, 0x64, 0x18, 0xD8, 0xF1, 0xA5,  
 100              0x29, 0x55, 0x7D, 0xA5, 0x85, 0x95, 0x02, 0x1A, 0x2E, 0x3A, 0x56, 0x5A, 0x40, 0x48, 0xF9, 0xF3,  
 101              0xA3, 0xD9, 0xF8, 0xF0, 0x98, 0x83, 0x24, 0x08, 0x44, 0x10, 0x64, 0x18, 0x97, 0x82, 0xA8, 0xF1,  
 102              0x11, 0xF0, 0x98, 0xA2, 0x24, 0x08, 0x44, 0x10, 0x64, 0x18, 0xDA, 0xF3, 0xDE, 0xD8, 0x83, 0xA5,  
 103              0x94, 0x01, 0xD9, 0xA3, 0x02, 0xF1, 0xA2, 0xC3, 0xC5, 0xC7, 0xD8, 0xF1, 0x84, 0x92, 0xA2, 0x4D,  
 104              0xDA, 0x2A, 0xD8, 0x48, 0x69, 0xD9, 0x2A, 0xD8, 0x68, 0x55, 0xDA, 0x32, 0xD8, 0x50, 0x71, 0xD9,  
 105              0x32, 0xD8, 0x70, 0x5D, 0xDA, 0x3A, 0xD8, 0x58, 0x79, 0xD9, 0x3A, 0xD8, 0x78, 0x93, 0xA3, 0x4D,  
 106              0xDA, 0x2A, 0xD8, 0x48, 0x69, 0xD9, 0x2A, 0xD8, 0x68, 0x55, 0xDA, 0x32, 0xD8, 0x50, 0x71, 0xD9,  
 107              0x32, 0xD8, 0x70, 0x5D, 0xDA, 0x3A, 0xD8, 0x58, 0x79, 0xD9, 0x3A, 0xD8, 0x78, 0xA8, 0x8A, 0x9A,  
 108              0xF0, 0x28, 0x50, 0x78, 0x9E, 0xF3, 0x88, 0x18, 0xF1, 0x9F, 0x1D, 0x98, 0xA8, 0xD9, 0x08, 0xD8,  
 109              0xC8, 0x9F, 0x12, 0x9E, 0xF3, 0x15, 0xA8, 0xDA, 0x12, 0x10, 0xD8, 0xF1, 0xAF, 0xC8, 0x97, 0x87,  
 110              // bank 5, 256 bytes  
 111              0x34, 0xB5, 0xB9, 0x94, 0xA4, 0x21, 0xF3, 0xD9, 0x22, 0xD8, 0xF2, 0x2D, 0xF3, 0xD9, 0x2A, 0xD8,  
 112              0xF2, 0x35, 0xF3, 0xD9, 0x32, 0xD8, 0x81, 0xA4, 0x60, 0x60, 0x61, 0xD9, 0x61, 0xD8, 0x6C, 0x68,  
 113              0x69, 0xD9, 0x69, 0xD8, 0x74, 0x70, 0x71, 0xD9, 0x71, 0xD8, 0xB1, 0xA3, 0x84, 0x19, 0x3D, 0x5D,  
 114              0xA3, 0x83, 0x1A, 0x3E, 0x5E, 0x93, 0x10, 0x30, 0x81, 0x10, 0x11, 0xB8, 0xB0, 0xAF, 0x8F, 0x94,  
 115              0xF2, 0xDA, 0x3E, 0xD8, 0xB4, 0x9A, 0xA8, 0x87, 0x29, 0xDA, 0xF8, 0xD8, 0x87, 0x9A, 0x35, 0xDA,  
 116              0xF8, 0xD8, 0x87, 0x9A, 0x3D, 0xDA, 0xF8, 0xD8, 0xB1, 0xB9, 0xA4, 0x98, 0x85, 0x02, 0x2E, 0x56,  
 117              0xA5, 0x81, 0x00, 0x0C, 0x14, 0xA3, 0x97, 0xB0, 0x8A, 0xF1, 0x2D, 0xD9, 0x28, 0xD8, 0x4D, 0xD9,  
C51 COMPILER V9.52.0.0   51MPU6050DMP                                                      08/28/2017 09:30:04 PAGE 3   

 118              0x48, 0xD8, 0x6D, 0xD9, 0x68, 0xD8, 0xB1, 0x84, 0x0D, 0xDA, 0x0E, 0xD8, 0xA3, 0x29, 0x83, 0xDA,  
 119              0x2C, 0x0E, 0xD8, 0xA3, 0x84, 0x49, 0x83, 0xDA, 0x2C, 0x4C, 0x0E, 0xD8, 0xB8, 0xB0, 0xA8, 0x8A,  
 120              0x9A, 0xF5, 0x20, 0xAA, 0xDA, 0xDF, 0xD8, 0xA8, 0x40, 0xAA, 0xD0, 0xDA, 0xDE, 0xD8, 0xA8, 0x60,  
 121              0xAA, 0xDA, 0xD0, 0xDF, 0xD8, 0xF1, 0x97, 0x86, 0xA8, 0x31, 0x9B, 0x06, 0x99, 0x07, 0xAB, 0x97,  
 122              0x28, 0x88, 0x9B, 0xF0, 0x0C, 0x20, 0x14, 0x40, 0xB8, 0xB0, 0xB4, 0xA8, 0x8C, 0x9C, 0xF0, 0x04,  
 123              0x28, 0x51, 0x79, 0x1D, 0x30, 0x14, 0x38, 0xB2, 0x82, 0xAB, 0xD0, 0x98, 0x2C, 0x50, 0x50, 0x78,  
 124              0x78, 0x9B, 0xF1, 0x1A, 0xB0, 0xF0, 0x8A, 0x9C, 0xA8, 0x29, 0x51, 0x79, 0x8B, 0x29, 0x51, 0x79,  
 125              0x8A, 0x24, 0x70, 0x59, 0x8B, 0x20, 0x58, 0x71, 0x8A, 0x44, 0x69, 0x38, 0x8B, 0x39, 0x40, 0x68,  
 126              0x8A, 0x64, 0x48, 0x31, 0x8B, 0x30, 0x49, 0x60, 0xA5, 0x88, 0x20, 0x09, 0x71, 0x58, 0x44, 0x68,  
 127              // bank 6, 256 bytes  
 128              0x11, 0x39, 0x64, 0x49, 0x30, 0x19, 0xF1, 0xAC, 0x00, 0x2C, 0x54, 0x7C, 0xF0, 0x8C, 0xA8, 0x04,  
 129              0x28, 0x50, 0x78, 0xF1, 0x88, 0x97, 0x26, 0xA8, 0x59, 0x98, 0xAC, 0x8C, 0x02, 0x26, 0x46, 0x66,  
 130              0xF0, 0x89, 0x9C, 0xA8, 0x29, 0x51, 0x79, 0x24, 0x70, 0x59, 0x44, 0x69, 0x38, 0x64, 0x48, 0x31,  
 131              0xA9, 0x88, 0x09, 0x20, 0x59, 0x70, 0xAB, 0x11, 0x38, 0x40, 0x69, 0xA8, 0x19, 0x31, 0x48, 0x60,  
 132              0x8C, 0xA8, 0x3C, 0x41, 0x5C, 0x20, 0x7C, 0x00, 0xF1, 0x87, 0x98, 0x19, 0x86, 0xA8, 0x6E, 0x76,  
 133              0x7E, 0xA9, 0x99, 0x88, 0x2D, 0x55, 0x7D, 0x9E, 0xB9, 0xA3, 0x8A, 0x22, 0x8A, 0x6E, 0x8A, 0x56,  
 134              0x8A, 0x5E, 0x9F, 0xB1, 0x83, 0x06, 0x26, 0x46, 0x66, 0x0E, 0x2E, 0x4E, 0x6E, 0x9D, 0xB8, 0xAD,  
 135              0x00, 0x2C, 0x54, 0x7C, 0xF2, 0xB1, 0x8C, 0xB4, 0x99, 0xB9, 0xA3, 0x2D, 0x55, 0x7D, 0x81, 0x91,  
 136              0xAC, 0x38, 0xAD, 0x3A, 0xB5, 0x83, 0x91, 0xAC, 0x2D, 0xD9, 0x28, 0xD8, 0x4D, 0xD9, 0x48, 0xD8,  
 137              0x6D, 0xD9, 0x68, 0xD8, 0x8C, 0x9D, 0xAE, 0x29, 0xD9, 0x04, 0xAE, 0xD8, 0x51, 0xD9, 0x04, 0xAE,  
 138              0xD8, 0x79, 0xD9, 0x04, 0xD8, 0x81, 0xF3, 0x9D, 0xAD, 0x00, 0x8D, 0xAE, 0x19, 0x81, 0xAD, 0xD9,  
 139              0x01, 0xD8, 0xF2, 0xAE, 0xDA, 0x26, 0xD8, 0x8E, 0x91, 0x29, 0x83, 0xA7, 0xD9, 0xAD, 0xAD, 0xAD,  
 140              0xAD, 0xF3, 0x2A, 0xD8, 0xD8, 0xF1, 0xB0, 0xAC, 0x89, 0x91, 0x3E, 0x5E, 0x76, 0xF3, 0xAC, 0x2E,  
 141              0x2E, 0xF1, 0xB1, 0x8C, 0x5A, 0x9C, 0xAC, 0x2C, 0x28, 0x28, 0x28, 0x9C, 0xAC, 0x30, 0x18, 0xA8,  
 142              0x98, 0x81, 0x28, 0x34, 0x3C, 0x97, 0x24, 0xA7, 0x28, 0x34, 0x3C, 0x9C, 0x24, 0xF2, 0xB0, 0x89,  
 143              0xAC, 0x91, 0x2C, 0x4C, 0x6C, 0x8A, 0x9B, 0x2D, 0xD9, 0xD8, 0xD8, 0x51, 0xD9, 0xD8, 0xD8, 0x79,  
 144              // bank 7, 138 bytes (remainder)  
 145              0xD9, 0xD8, 0xD8, 0xF1, 0x9E, 0x88, 0xA3, 0x31, 0xDA, 0xD8, 0xD8, 0x91, 0x2D, 0xD9, 0x28, 0xD8,  
 146              0x4D, 0xD9, 0x48, 0xD8, 0x6D, 0xD9, 0x68, 0xD8, 0xB1, 0x83, 0x93, 0x35, 0x3D, 0x80, 0x25, 0xDA,  
 147              0xD8, 0xD8, 0x85, 0x69, 0xDA, 0xD8, 0xD8, 0xB4, 0x93, 0x81, 0xA3, 0x28, 0x34, 0x3C, 0xF3, 0xAB,  
 148              0x8B, 0xF8, 0xA3, 0x91, 0xB6, 0x09, 0xB4, 0xD9, 0xAB, 0xDE, 0xFA, 0xB0, 0x87, 0x9C, 0xB9, 0xA3,  
 149              0xDD, 0xF1, 0xA3, 0xA3, 0xA3, 0xA3, 0x95, 0xF1, 0xA3, 0xA3, 0xA3, 0x9D, 0xF1, 0xA3, 0xA3, 0xA3,  
 150              0xA3, 0xF2, 0xA3, 0xB4, 0x90, 0x80, 0xF2, 0xA3, 0xA3, 0xA3, 0xA3, 0xA3, 0xA3, 0xA3, 0xA3, 0xA3,  
 151              0xA3, 0xB2, 0xA3, 0xA3, 0xA3, 0xA3, 0xA3, 0xA3, 0xB0, 0x87, 0xB5, 0x99, 0xF1, 0xA3, 0xA3, 0xA3,  
 152              0x98, 0xF1, 0xA3, 0xA3, 0xA3, 0xA3, 0x97, 0xA3, 0xA3, 0xA3, 0xA3, 0xF3, 0x9B, 0xA3, 0xA3, 0xDC,  
 153              0xB9, 0xA7, 0xF1, 0x26, 0x26, 0x26, 0xD8, 0xD8, 0xFF  
 154          };  
 155          code unsigned char dmpcfgupddata[192] = {  
 156          //  dmp config   
 157          //  BANK    OFFSET  LENGTH  [DATA]  
 158              0x03,   0x7B,   0x03,   0x4C, 0xCD, 0x6C,           
 159              0x03,   0xAB,   0x03,   0x36, 0x56, 0x76,           
 160              0x00,   0x68,   0x04,   0x02, 0xCB, 0x47, 0xA2,     
 161              0x02,   0x18,   0x04,   0x00, 0x05, 0x8B, 0xC1,     
 162              0x01,   0x0C,   0x04,   0x00, 0x00, 0x00, 0x00,     
 163              0x03,   0x7F,   0x06,   0x0C, 0xC9, 0x2C, 0x97, 0x97, 0x97,   
 164              0x03,   0x89,   0x03,   0x26, 0x46, 0x66,           
 165              0x00,   0x6C,   0x02,   0x20, 0x00,                 
 166              0x02,   0x40,   0x04,   0x00, 0x00, 0x00, 0x00,     
 167              0x02,   0x44,   0x04,   0x00, 0x00, 0x00, 0x00,     
 168              0x02,   0x48,   0x04,   0x00, 0x00, 0x00, 0x00,     
 169              0x02,   0x4C,   0x04,   0x00, 0x00, 0x00, 0x00,     
 170              0x02,   0x50,   0x04,   0x00, 0x00, 0x00, 0x00,     
 171              0x02,   0x54,   0x04,   0x00, 0x00, 0x00, 0x00,    
 172              0x02,   0x58,   0x04,   0x00, 0x00, 0x00, 0x00,    
 173              0x02,   0x5C,   0x04,   0x00, 0x00, 0x00, 0x00,    
 174              0x02,   0xBC,   0x04,   0x00, 0x00, 0x00, 0x00,     
 175              0x01,   0xEC,   0x04,   0x00, 0x00, 0x40, 0x00,    
 176              0x03,   0x7F,   0x06,   0x0C, 0xC9, 0x2C, 0x97, 0x97, 0x97,  
 177              0x04,   0x02,   0x03,   0x0D, 0x35, 0x5D,           
 178              0x04,   0x09,   0x04,   0x87, 0x2D, 0x35, 0x3D,     
 179              0x00,   0xA3,   0x01,   0x00,                      
C51 COMPILER V9.52.0.0   51MPU6050DMP                                                      08/28/2017 09:30:04 PAGE 4   

 180              0x00,   0x00,   0x00,   0x01,   //这里是开启DMP的特殊中断的  
 181              //原程序中此行代码为(这里不一定错)  
 182              //0x00,   0x00,   0x00,   0x01,  即LENGTH=0x00，有错  
 183                    
 184              0x07,   0x86,   0x01,   0xFE,                       
 185              0x07,   0x41,   0x05,   0xF1, 0x20, 0x28, 0x30, 0x38,   
 186              0x07,   0x7E,   0x01,   0x30,                     
 187              0x07,   0x46,   0x01,   0x9A,                      
 188              0x07,   0x47,   0x04,   0xF1, 0x28, 0x30, 0x38,     
 189              0x07,   0x6C,   0x04,   0xF1, 0x28, 0x30, 0x38,    
 190              0x02,   0x16,   0x02,   0x00, 0x01,                
 191          /* 上行最后一个数据调整FIFO rate :0x01=100HZ,0x02=66HZ,0x03=50HZ ,0x04=40HZ,0x05=33.33HZ,  
 192          // 可从 datasheet 公式推算 
 193          //dmp updates 
 194              0x01,   0xB2,   0x02,   0xFF, 0xFF, 
 195              0x01,   0x90,   0x04,   0x09, 0x23, 0xA1, 0x35, 
 196              0x01,   0x6A,   0x02,   0x06, 0x00, 
 197              0x01,   0x60,   0x08,   0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
 198              0x00,   0x60,   0x04,   0x40, 0x00, 0x00, 0x00, 
 199              0x01,   0x62,   0x02,   0x00, 0x00, 
 200              0x00,   0x60,   0x04,   0x00, 0x40, 0x00, 0x00*/  
 201          };  
 202          code unsigned char dmpUpdates[47]={  
 203                
 204              0x01,   0xB2,   0x02,   0xFF, 0xFF,  
 205              0x01,   0x90,   0x04,   0x09, 0x23, 0xA1, 0x35,  
 206              0x01,   0x6A,   0x02,   0x06, 0x00,  
 207              0x01,   0x60,   0x08,   0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,  
 208              0x00,   0x60,   0x04,   0x40, 0x00, 0x00, 0x00,  
 209              0x01,   0x62,   0x02,   0x00, 0x00,  
 210              0x00,   0x60,   0x04,   0x00, 0x40, 0x00, 0x00  
 211                
 212          };  
 213          void DelayUs2x(unsigned char t) //延时1  
 214          {     
 215   1       while(--t);  
 216   1      }  
 217            
 218          void DelayMs(unsigned char t)   //延时2  
 219          {  
 220   1             
 221   1       while(t--)  
 222   1       {  
 223   2           //大致延时1mS  
 224   2           DelayUs2x(245);  
 225   2           DelayUs2x(245);  
 226   2       }  
 227   1      }  
 228            
 229          /*i2c基本协议*/  
 230          /*i2c基本协议*/  
 231          void i2_qs(void)    //启始信号  
 232          {  
 233   1          sda = 1;  
 234   1          scl = 1;  
 235   1          _nop_();  
 236   1          sda = 0;  
 237   1          _nop_();_nop_();  
 238   1          _nop_();_nop_();  
 239   1          scl = 0;  
 240   1      }  
 241            
C51 COMPILER V9.52.0.0   51MPU6050DMP                                                      08/28/2017 09:30:04 PAGE 5   

 242          void i2_tz()    //停止信号  
 243          {  
 244   1          sda = 0;  
 245   1          scl = 1;  
 246   1          _nop_();_nop_();  
 247   1          _nop_();_nop_();  
 248   1          sda = 1;  
 249   1          _nop_();  
 250   1      }  
 251          void i2_fs(unsigned char Data)  //发送8位数据  
 252          {  
 253   1          unsigned char i=0;  
 254   1          for(;i<8;i++)  
 255   1          {  
 256   2              Data <<= 1;  
 257   2              sda = CY;  
 258   2              scl = 1;  
 259   2              _nop_();_nop_();  
 260   2              _nop_();_nop_();  
 261   2              scl = 0;  
 262   2                
 263   2          }  
 264   1          //下面是接收从设备发回的应答信号  
 265   1          sda = 1;  
 266   1          scl = 1;  
 267   1          _nop_();_nop_();  
 268   1          _nop_();_nop_();  
 269   1          ack = sda;  //接收设备的ack  _n  
 270   1          scl = 0;  
 271   1          sda = 1;  
 272   1      }  
 273            
 274          unsigned char i2_js(bit _ack)   //接收8位数据  
 275          {  
 276   1          unsigned char i = 0,Data = 0;  
 277   1          for(;i<8;i++)  
 278   1          {  
 279   2              Data <<= 1;  
 280   2              scl = 1;  
 281   2              _nop_();_nop_();  
 282   2              _nop_();_nop_();  
 283   2              Data |= sda;    //接收数据  
 284   2              scl = 0;  
 285   2              _nop_();  
 286   2          }  
 287   1          //下面时主控器发送ACK或则NAK  
 288   1          sda = _ack; //ack或者nak  
 289   1          scl = 1;    //拉高时钟产生第9个时钟  
 290   1          _nop_();_nop_();  
 291   1          _nop_();_nop_();  
 292   1          scl = 0;    //拉底时钟  
 293   1          sda = 1;    //释放总线  
 294   1          _nop_();  
 295   1          return Data;  
 296   1      }  
 297          /*i2c协议基本*/  
 298            
 299          /*写入8位寄存器一个字节 
 300            参数 addr 寄存器地址 
 301            参数 Data 写入数据 
 302            返回值 (1=成功,0=失败) 
 303          */  
C51 COMPILER V9.52.0.0   51MPU6050DMP                                                      08/28/2017 09:30:04 PAGE 6   

 304          unsigned char i2cwrite(unsigned char addr,unsigned char Data)   //写入8位有效数据  
 305          {  
 306   1          i2_qs();    //起始信号  
 307   1          i2_fs(SlaveAddress);    //设备地址+写信号  
 308   1          if(ack) return 0;   //判断是否是ACK如果不是返回0  
 309   1          i2_fs(addr);    //设备内部地址  
 310   1          if(ack) return 0;  
 311   1          i2_fs(Data);    //写入的数据  
 312   1          if(ack) return 0;  
 313   1          i2_tz();    //停止信号  
 314   1          return 1;  
 315   1      }  
 316          /*读取8位寄存器一个字节 
 317            参数 addr 寄存器地址 
 318            参数 *Data 数据存储地址 
 319            返回值 (1=成功,0=失败) 
 320          */  
 321          unsigned char i2cread(unsigned char addr,unsigned char *Data)     
 322          {  
 323   1          /*unsigned char Data1; 
 324   1          i2_qs();    //起始信号 
 325   1          i2_fs(SlaveAddress);    //设备地址+写信号 
 326   1          SendByte(ack); 
 327   1          i2_fs(addr);    //设备内部地址 
 328   1          i2_qs();    //起始信号 
 329   1          i2_fs(SlaveAddress+1);  //设备地址+读信号 
 330   1          *Data = i2_js(1);   //读取数据 
 331   1          i2_tz();    //停止信号*/  
 332   1          return i2creads(addr,1,Data);  
 333   1      }  
 334          /*读取8位寄存器多个字节 
 335           * @参数 addr    I2C从器件内部地址 
 336           * @参数 length  写入数据长度     
 337           * @参数 Data    保存数据的地址       
 338           * @返回值 返回状态 (1=成功) 
 339           */  
 340          unsigned char i2creads(unsigned char addr,unsigned char length,unsigned char *Data)  
 341          {  
 342   1              unsigned char i;  
 343   1              length --;  
 344   1              i2_qs();    //起始信号  
 345   1              i2_fs(SlaveAddress);    //设备地址+写信号  
 346   1              if(ack) return 0;  
 347   1              i2_fs(addr);    //设备内部地址  
 348   1              if(ack) return 0;  
 349   1              i2_qs();    //起始信号  
 350   1              i2_fs(SlaveAddress+1);  //设备地址+读信号  
 351   1              if(ack) return 0;  
 352   1              for(i=0;i<length;i++)  
 353   1              {  
 354   2                  Data[i]= i2_js(0);  //读取数据,发送ACK  
 355   2              }  
 356   1              Data[length] = i2_js(1);//读取数据,发送NAK  
 357   1              i2_tz();    //停止信号  
 358   1              return 1;  
 359   1      }  
 360            
 361          /**写入8位寄存器的一个位。 
 362           * @参数 addr    I2C从器件内部地址 
 363           * @参数 bitNum  写入的比特位(0-7)      
 364           * @参数 data    写入数据       
 365           * @返回值 返回状态 (1=成功) 
C51 COMPILER V9.52.0.0   51MPU6050DMP                                                      08/28/2017 09:30:04 PAGE 7   

 366           */  
 367          unsigned char writeBit(unsigned char addr,unsigned char bitNum,unsigned char Data)  
 368          {  
 369   1          unsigned char b;  
 370   1          if (i2cread(addr,&b))  
 371   1              {  
 372   2                  b = (Data != 0) ? (b | (1 << bitNum)):(b & ~(1 << bitNum));   
 373   2                  return i2cwrite(addr,b);    //写入数据  
 374   2              }  
 375   1          else  
 376   1              return 0;  
 377   1      }  
 378          /**写入8位寄存器的多个位。   
 379           * @参数 addr     I2C从器件内部地址 
 380           * @参数 bitStart 第一位的写入位置（0-7） 
 381           * @参数 length   写的比特数(不超过8) 
 382           * @参数 Data     写入数据 
 383           * @返回值 返回状态 (1=成功) 
 384           */  
 385          unsigned char writeBits(unsigned char addr,unsigned char bitStart,unsigned char length,unsigned char Data)
             -  
 386          {  
 387   1              //      010 要写入的值  
 388   1          // 76543210 比特位  
 389   1          //    xxx   args: bitStart=4, length=3  
 390   1          // 00011100 掩码字节  
 391   1          // 10101111 原始值（样本）  
 392   1          // 10100011 原始值 & ~掩码  
 393   1          // 10101011 掩码 | 原始值  
 394   1          unsigned char b,mask=0;  
 395   1          if (i2cread(addr,&b))  
 396   1          {  
 397   2              mask = (((1<<length) - 1) << (bitStart-length + 1));    //掩码  
 398   2              Data <<=(bitStart - length + 1);  //把写入的数据移动到位  
 399   2              Data &= mask;  
 400   2              b &= ~(mask);  
 401   2              b |= Data;  
 402   2              i2cwrite(addr,b);   //写入数据  
 403   2              return 1;  
 404   2          }  
 405   1          else  
 406   1              return 0;  
 407   1      }  
 408          /**读取一个位从8位器件的寄存器。   
 409          * @参数 addr    I2C从器件内部地址 
 410          * @参数 bitNum  位的位置来读取（0-7）  
 411          * @参数 *data   数据存储地址   
 412          * @返回值（1=成功）  
 413          */  
 414          unsigned char readBit(unsigned char addr,unsigned char bitNum,unsigned char *Data)  
 415          {  
 416   1          unsigned char b;  
 417   1          if(i2cread(addr,&b))  
 418   1          {  
 419   2              *Data = b & (1 << bitNum);  
 420   2              return 1;  
 421   2          }  
 422   1          else  
 423   1          {  
 424   2              return 0;  
 425   2          }  
 426   1      }  
C51 COMPILER V9.52.0.0   51MPU6050DMP                                                      08/28/2017 09:30:04 PAGE 8   

 427          /**读取8位寄存器的多个位。  
 428          * @参数 addr    I2C从器件内部地址  
 429          * @参数 bitStart第一位的位置读取（0-7）  
 430          * @参数 length  位读取@参数长度数（不超过8）  
 431          * @参数 *data   数据存储地址（即'101'任何bitStart位置读取将等于0X05）  
 432          * @返回值（1=成功）  
 433          */  
 434          unsigned char readBits(unsigned char addr,unsigned char bitStart,unsigned char length,unsigned char *Data)
             -  
 435          {  
 436   1              // 01101001 读取字节  
 437   1          // 76543210 比特位  
 438   1          //    xxx   args: bitStart=4, length=3  
 439   1          //    010   masked  
 440   1          //   -> 010 shifted  
 441   1          unsigned char b,mask=0;  
 442   1          if(i2cread(addr,&b))  
 443   1          {  
 444   2                
 445   2              mask = ((1 << length) - 1) << (bitStart - length + 1);  
 446   2              b &= mask;  
 447   2              b >>= (bitStart - length + 1);  
 448   2              *Data = b;  
 449   2              return 1;  
 450   2          }  
 451   1          else  
 452   1              return 0;  
 453   1      }  
 454            
 455            
 456          /*void init6050()   //初始化 6050 
 457          { 
 458            i2cwrite(0x6b,0x80);                                          //电源管理（0x00 正常启用）               
             -    
 459             
 460            i2cwrite(0x6b ,0x01);                          //No sleep  , 3 PLL with X axis gyroscope reference电源管
             -理 
 461            DelayMs(200); 
 462            i2cwrite(0x23 ,0x00);                          //FIFO 11111000 ,temp,gx,gy,gz,accel？ 
 463            i2cwrite(0x19 ,0x05);                          //陀螺仪采样率 
 464            i2cwrite(0x1a ,0x03);                          //低通滤波 
 465            i2cwrite(0x1b ,0x18);                          //陀螺仪自检，量程范围 2000 /s 
 466            i2cwrite(0x1c ,0x00);                          //加速计自检，量程范围及 高通滤波频率   +-2g/s 
 467          }  
 468           */  
 469             
 470           /* 
 471             加载 DMP代码到 
 472             返回值  (1=成功,0=失败) 
 473           */  
 474          unsigned char loadfirmware(void)      
 475          {  
 476   1        unsigned int datanum=0;   //DMP固件写入标志位  
 477   1        unsigned char ye,i,j;  
 478   1        unsigned char bank=0; //段（256个数据一段）  
 479   1        unsigned char addr=0;   
 480   1        
 481   1          for(;bank<8;bank++)  
 482   1          {  
 483   2              if(bank == 7)   //这里的作用就是区分最后一段数据  
 484   2                  i = 8;  
 485   2              else  
C51 COMPILER V9.52.0.0   51MPU6050DMP                                                      08/28/2017 09:30:04 PAGE 9   

 486   2                  i = 16;  
 487   2              for(ye=0;ye<i;ye++)  
 488   2              {  
 489   3                  i2cwrite(0x6d,bank);  
 490   3                  i2cwrite(0x6e,addr);  
 491   3                  i2_qs();    //起始信号  
 492   3                  i2_fs(SlaveAddress);    //设备地址+写信号  
 493   3                  i2_fs(0x6f);    //设备内部地址  
 494   3                  for(j=0;j<16;j++)  
 495   3                  {  
 496   4                      i2_fs(dmpmemorydata[datanum++]);    //写入DMP的数据  
 497   4                      if(ack) return 0;   
 498   4                  }  
 499   3                  addr += 16;  
 500   3                  i2_tz();    //停止信号  
 501   3              }  
 502   2          }  
 503   1          i2cwrite(0x6d,7);  
 504   1          i2cwrite(0x6e,addr);  
 505   1          i2_qs();    //起始信号  
 506   1          i2_fs(SlaveAddress);    //设备地址+写信号  
 507   1          i2_fs(0x6f);    //设备内部地址  
 508   1          for(i=0;i<9;i++)  
 509   1          {  
 510   2              i2_fs(dmpmemorydata[datanum++]);    //写入DMP的数据  
 511   2              if(ack) return 0;  
 512   2          }  
 513   1          i2_tz();    //停止信号  
 514   1          return 1;  
 515   1      }  
 516          unsigned char loadcfgupd(void)  //DMP设置  
 517          {  
 518   1        unsigned char line;   //一共需要写入30条设置数据  
 519   1        unsigned char bank;   //页  
 520   1        unsigned char datacounts=0;   //DMP设置数据标志位  
 521   1        unsigned char bytes2write;    //数据长度。  
 522   1        unsigned char offset; //偏移地址  
 523   1        unsigned char writingcounts;  //数据写入标志与bytes2write一同使用  
 524   1        unsigned char special;  
 525   1             
 526   1        for (line=0;line<30;line++)  
 527   1        {  
 528   2          bank=dmpcfgupddata[datacounts++];  
 529   2          offset=dmpcfgupddata[datacounts++];  
 530   2          bytes2write=dmpcfgupddata[datacounts++];  
 531   2          i2cwrite(0x6d,bank);  
 532   2          i2cwrite(0x6e,offset);  
 533   2          i2_qs();    //起始信号  
 534   2              i2_fs(SlaveAddress);    //设备地址+写信号  
 535   2              i2_fs(0x6f);    //设备内部地址  
 536   2          for(writingcounts=0;writingcounts<bytes2write;writingcounts++)  
 537   2          {  
 538   3              i2_fs(dmpcfgupddata[datacounts++]); //写入DMP配置数据  
 539   3                  if(ack) return 0;  
 540   3          }  
 541   2          if(0 == bytes2write)  
 542   2          {  
 543   3              special=dmpcfgupddata[datacounts++];  
 544   3              if(0x01 == special)  
 545   3                  {  
 546   4                      //设置零运动中断启用（真）;  
 547   4                //设置FIFO缓冲区溢出启用（真）;  
C51 COMPILER V9.52.0.0   51MPU6050DMP                                                      08/28/2017 09:30:04 PAGE 10  

 548   4                //设置DMP启用（真）;  
 549   4                      i2cwrite(0x38,0x32);  
 550   4                  }  
 551   3              else  
 552   3                  return 0;  
 553   3          }  
 554   2        }  
 555   1        i2_tz();  //停止信号  
 556   1          return 1;  
 557   1      }  
 558          /*最后更新DMP*/  
 559          unsigned char xdmpUpdates(unsigned char datacounts)  
 560          {  
 561   1          unsigned char writingcounts,bank,offset,bytes2write;  
 562   1          bank=dmpUpdates[datacounts++];  
 563   1        offset=dmpUpdates[datacounts++];  
 564   1        bytes2write=dmpUpdates[datacounts++];  
 565   1        i2cwrite(0x6d,bank);  
 566   1        i2cwrite(0x6e,offset);  
 567   1        i2_qs();  //起始信号  
 568   1          i2_fs(SlaveAddress);    //设备地址+写信号  
 569   1          i2_fs(0x6f);    //设备内部地址  
 570   1          for(writingcounts=0;writingcounts<bytes2write;writingcounts++)  
 571   1          {  
 572   2              i2_fs(dmpUpdates[datacounts++]);    //写入DMP配置数据  
 573   2                  if(ack) return 0;  
 574   2          }  
 575   1          i2_tz();    //停止信号  
 576   1          return 0;  
 577   1      }  
 578          /*读取 FIFO 计数*/  
 579          unsigned int getFIFOCount()  
 580          {  
 581   1          unsigned char i[2];  
 582   1          i2creads(0x72,2,i);  
 583   1          return ((i[0]<<8)+i[1]);  
 584   1      }  
 585          /*FIFO数据读取 
 586          参数 *Data    存储数据的地址 
 587          返回值 (1=读取成功,0读取失败) 
 588          */  
 589          unsigned char readdmp(unsigned char *Data)  
 590          {  
 591   1        return i2creads(0x74,42,Data);  
 592   1      }  
 593                
 594          //加载并配置 DMP 数字运动处理引擎  
 595          unsigned char dmpInitialize(void)  
 596          {  
 597   1          unsigned char hwRevision,otpValid,mpuIntStatus/*fifoBuffer[128]*/;  
 598   1          unsigned char xgOffsetTC,ygOffsetTC,zgOffsetTC;  
 599   1          unsigned int fifoCount;  
 600   1          writeBit(0x6B,7,1); //复位 MPU6050  
 601   1          DelayMs(30);  
 602   1          writeBit(0x6B,6,0); //禁止睡眠模式  
 603   1          i2cwrite(0x6D,0x70);    //写入一个字节数据到0x6d寄存器(选择用户 bank)  
 604   1          i2cwrite(0x6E,0x06);    //写入一个字节数据到0x6e寄存器(选择存储字节)  
 605   1          i2cread(0x6F,&hwRevision);  //读取  
 606   1          i2cwrite(0x6D,0);   //重置内存 bank 选择  
 607   1          readBit(0x00,0,&otpValid);  //读取 OTP bank 有效标志  
 608   1          readBits(0x00,6,6,&xgOffsetTC); //读陀螺偏置TC值 X  
 609   1          readBits(0x01,6,6,&ygOffsetTC); //读陀螺偏置TC值 Y)  
C51 COMPILER V9.52.0.0   51MPU6050DMP                                                      08/28/2017 09:30:04 PAGE 11  

 610   1          readBits(0x02,6,6,&zgOffsetTC); //读陀螺偏置TC值 Z  
 611   1          i2cwrite(0x25,0x7f);    //设置从0地址 0x7  
 612   1          writeBit(0x6A,5,0); //禁用I2C主模式  
 613   1          i2cwrite(0x25,0x68);    //这里可能要改。还没有弄明白这里  
 614   1          writeBit(0x6A,1,1); //I2C总线主控复位  
 615   1          DelayMs(20);  
 616   1          if((loadfirmware()) == 0 ) return 0;    //加载 DMP代码到内存  
 617   1          if((loadcfgupd()) == 0 ) return 0;  //配制DMP  
 618   1          writeBits(0x6B,2,3,0x03);   //设置时钟脉冲源Z陀螺  
 619   1          i2cwrite(0x38,0x12);    //设置DMP和FIFO_OFLOW启用中断  
 620   1          i2cwrite(0x19,4);   //设置采样率为200 hz  (1khz / (1 + 4) = 200 Hz)  
 621   1          writeBits(0x1A,5,3,0x1);    //设置外部帧同步TEMP_OUT_L[0]  
 622   1          writeBits(0x1A,2,3,0x03);   //设置DLPF带宽42赫兹  
 623   1          writeBits(0x1B,4,2,0x03);   //陀螺灵敏度设置为+ / - 2000 deg/sec  
 624   1          i2cwrite(0x70,0x03);    //设置DMP配置字节（功能未知）  
 625   1          i2cwrite(0x71,0x00);    //设置DMP配置字节（功能未知）  
 626   1          writeBit(0x00,0,0); //清除OTP Bank 标志  
 627   1          writeBits(0x00,6,6,xgOffsetTC); //设置X 陀螺抵消TCs之前的值  
 628   1          writeBits(0x01,6,6,ygOffsetTC); //设置Y 陀螺抵消TCs之前的值  
 629   1          writeBits(0x02,6,6,zgOffsetTC); //设置Z 陀螺抵消TCs之前的值  
 630   1          xdmpUpdates(0); //最后更新1/7(函数未知)dmpUpdates数组第一行  
 631   1          xdmpUpdates(5); //最后更新2/7(函数未知)dmpUpdates数组第二行  
 632   1          writeBit(0x6A,2,1); //复位 FIFO  
 633   1          fifoCount = getFIFOCount(); //读取 FIFO 计数  
 634   1          //readdmp(fifoCount,fifoBuffer);    //读取FIFO里的数据  
 635   1          writeBit(0x6A,2,1); //复位 FIFO  
 636   1            
 637   1          i2cwrite(0x1F,2);   //运动检测阈值设置为2  
 638   1          i2cwrite(0x21,156); //零运动检测阈值为156  
 639   1          i2cwrite(0x20,80);  //设置运动检测持续时间至80  
 640   1          i2cwrite(0x22,0);   //设置零运动检测时间0  
 641   1          writeBit(0x6A,2,1); //复位 FIFO  
 642   1          writeBit(0x6A,6,1); //使能 FIFO  
 643   1          writeBit(0x6A,7,1); //使能 DMP  
 644   1          writeBit(0x6A,3,1); //复位 DMP  
 645   1          xdmpUpdates(12);    //最后更新3/7(函数未知)dmpUpdates数组第三行  
 646   1          xdmpUpdates(17);    //最后更新4/7(函数未知)dmpUpdates数组第四行  
 647   1          xdmpUpdates(28);    //最后更新5/7(函数未知)dmpUpdates数组第五行  
 648   1          while((fifoCount = getFIFOCount()) < 3); //等待 FIFO 计数 > 2  
 649   1          writeBit(0x6A,2,1); //复位 FIFO  
 650   1          //readdmp(fifoCount,fifoBuffer);    //读取FIFO里的数据  
 651   1          i2cread(0x3A,&mpuIntStatus);    //读取中断状态  
 652   1          xdmpUpdates(35);    //最后更新6/7(函数未知)dmpUpdates数组第六行  
 653   1          while((fifoCount = getFIFOCount()) < 3); //等待 FIFO 计数 > 2  
 654   1          writeBit(0x6A,2,1); //复位 FIFO  
 655   1          //readdmp(fifoCount,fifoBuffer);    //读取FIFO里的数据  
 656   1          i2cread(0x3A,&mpuIntStatus);    //读取中断状态  
 657   1          xdmpUpdates(40);    //最后更新7/7(函数未知)dmpUpdates数组第七行  
 658   1          writeBit(0x6A,7,0); //禁用DMP(稍后您打开它)  
 659   1          writeBit(0x6A,2,1); //复位 FIFO  
 660   1          i2cread(0x3A,&mpuIntStatus);  
 661   1          //星期六 (2014/06/28)  
 662   1          return 1;  
 663   1      }  
 664          /*初始化MPU6050*/  
 665          void initMPU6050(void)  
 666          {  
 667   1          writeBits (0x6B,2,3,0x01);  //电源管理  
 668   1          writeBits (0x1B,4,2,0x00);  //设置陀螺仪量程 250/s  
 669   1          writeBits (0x1C,4,2,0x00);  //设置加速度量程 2G  
 670   1          writeBit (0x6B,6,1);    //电源管理MUP进入睡眠模式  
 671   1      }  
C51 COMPILER V9.52.0.0   51MPU6050DMP                                                      08/28/2017 09:30:04 PAGE 12  

 672          /*验证MPU6050连接*/  
 673          unsigned char getDeviceID(void)  
 674          {  
 675   1          unsigned char b=0;  //临时变量  
 676   1          readBits(0x75,6,6,&b);  //读取i2c固定地址，去掉最高位和最低位这两位数据  
 677   1          return b == 0x34;   //判断B是否等于0x34，如果等于返回1，不等于返回0(库的是0x38)  
 678   1            
 679   1      }  
 680          /**************************************串口**********************************/  
 681          void CSH  (void) //初始化串口  
 682          {  
 683   1        
 684   1          SCON  = 0x50;               // SCON: 模式 1, 8-bit UART, 使能接收    
 685   1          TMOD |= 0x20;               // TMOD: timer 1, mode 2, 8-bit 重装  
 686   1          TH1   = 0xFD;               // TH1:  重装值 9600 波特率 晶振 11.0592MHz    
 687   1          TR1   = 1;                  // TR1:  timer 1 打开                           
 688   1          EA    = 1;                  //打开总中断  
 689   1          //ES    = 1;                  //打开串口中断  
 690   1      }  
 691          void SendByte(unsigned char dat) //发送一个字符  
 692          {  
 693   1       SBUF = dat; //SBUF 串行数据缓冲器  
 694   1       while(!TI);  //TI发送中断标志位 (当数据发送完毕后由硬件置 1 否则等待硬件置 1)  
 695   1            TI = 0;   
 696   1      }  
 697          /************************************************************************************/  
 698            
 699          //void main(void)  
 700          //{  
 701          //    unsigned char zd,i;  
 702          //    CSH();  //初始化串口  
 703          //    initMPU6050();  //初始化  
 704          //    if (getDeviceID())  //验证连接是否正常(读取MPU6050的I2C地址)  
 705          //    {  
 706          //        if(!(dmpInitialize()))  //加载并配置运动库  
 707          //            while(1);  
 708          //              
 709          //    }  
 710          //    writeBit(0x6A,2,1); //复位 FIFO  
 711          //    writeBit(0x6A,7,1); //使能DMP  
 712          //while(1)  
 713          // {  
 714          //    i=getFIFOCount();//读取FIFO计数  
 715          //    i2cread(0x3A,&zd);  //读取中断状态  
 716          //    if((zd & 0x10)||i==1024)    //判断FIFO是否溢出  
 717          //    {  
 718          //        writeBit(0x6A,2,1); //复位 FIFO  
 719          //    }  
 720          //    else if (zd & 0x02)  
 721          //    {  
 722          //        while(i<42) i=getFIFOCount();  
 723          //        readdmp(dmpdatas);  //读取FIFO数据(四元数+其他的数据)  
 724          //        SendByte(dmpdatas[0]);  
 725          //        SendByte(dmpdatas[1]);  
 726          //            SendByte(dmpdatas[4]);   
 727          //        SendByte(dmpdatas[5]);  
 728          //        SendByte(dmpdatas[8]);  
 729          //        SendByte(dmpdatas[9]);  
 730          //        SendByte(dmpdatas[12]);  
 731          //        SendByte(dmpdatas[13]);  
 732          //    }  
 733          //  
C51 COMPILER V9.52.0.0   51MPU6050DMP                                                      08/28/2017 09:30:04 PAGE 13  

 734          // }  
 735          //}  


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =   1529    ----
   CONSTANT SIZE    =   2168    ----
   XDATA SIZE       =   ----    ----
   PDATA SIZE       =   ----    ----
   DATA SIZE        =     42      41
   IDATA SIZE       =   ----    ----
   BIT SIZE         =      1       1
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
