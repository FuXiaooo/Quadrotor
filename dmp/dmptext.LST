C51 COMPILER V9.52.0.0   DMPTEXT                                                           08/29/2017 15:52:11 PAGE 1   


C51 COMPILER V9.52.0.0, COMPILATION OF MODULE DMPTEXT
OBJECT MODULE PLACED IN dmptext.OBJ
COMPILER INVOKED BY: D:\c51v952\C51\BIN\C51.EXE dmptext.c LARGE BROWSE DEBUG OBJECTEXTEND TABS(2)

line level    source

   1          #include <dmptext.h>
   2          #include <i2c.h>
   3          #include <math.h>
   4          
   5          
   6          #define M_PI 3.141592654
   7          
   8          
   9          
  10          
  11          
  12          code unsigned char dmpmemorydata[1929]={  
  13           // bank 0, 256 bytes  
  14              0xFB, 0x00, 0x00, 0x3E, 0x00, 0x0B, 0x00, 0x36, 0x00, 0x01, 0x00, 0x02, 0x00, 0x03, 0x00, 0x00,  
  15              0x00, 0x65, 0x00, 0x54, 0xFF, 0xEF, 0x00, 0x00, 0xFA, 0x80, 0x00, 0x0B, 0x12, 0x82, 0x00, 0x01,  
  16              0x00, 0x02, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,  
  17              0x00, 0x28, 0x00, 0x00, 0xFF, 0xFF, 0x45, 0x81, 0xFF, 0xFF, 0xFA, 0x72, 0x00, 0x00, 0x00, 0x00,  
  18              0x00, 0x00, 0x03, 0xE8, 0x00, 0x00, 0x00, 0x01, 0x00, 0x01, 0x7F, 0xFF, 0xFF, 0xFE, 0x80, 0x01,  
  19              0x00, 0x1B, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,  
  20              0x00, 0x3E, 0x03, 0x30, 0x40, 0x00, 0x00, 0x00, 0x02, 0xCA, 0xE3, 0x09, 0x3E, 0x80, 0x00, 0x00,  
  21              0x20, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x40, 0x00, 0x00, 0x00, 0x60, 0x00, 0x00, 0x00,  
  22              0x41, 0xFF, 0x00, 0x00, 0x00, 0x00, 0x0B, 0x2A, 0x00, 0x00, 0x16, 0x55, 0x00, 0x00, 0x21, 0x82,  
  23              0xFD, 0x87, 0x26, 0x50, 0xFD, 0x80, 0x00, 0x00, 0x00, 0x1F, 0x00, 0x00, 0x00, 0x05, 0x80, 0x00,  
  24              0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x02, 0x00, 0x00, 0x00, 0x03, 0x00, 0x00,  
  25              0x40, 0x00, 0x00, 0x00, 0x00, 0x00, 0x04, 0x6F, 0x00, 0x02, 0x65, 0x32, 0x00, 0x00, 0x5E, 0xC0,  
  26              0x40, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,  
  27              0xFB, 0x8C, 0x6F, 0x5D, 0xFD, 0x5D, 0x08, 0xD9, 0x00, 0x7C, 0x73, 0x3B, 0x00, 0x6C, 0x12, 0xCC,  
  28              0x32, 0x00, 0x13, 0x9D, 0x32, 0x00, 0xD0, 0xD6, 0x32, 0x00, 0x08, 0x00, 0x40, 0x00, 0x01, 0xF4,  
  29              0xFF, 0xE6, 0x80, 0x79, 0x02, 0x00, 0x00, 0x00, 0x00, 0x00, 0xD0, 0xD6, 0x00, 0x00, 0x27, 0x10,  
  30              // bank 1, 256 bytes  
  31              0xFB, 0x00, 0x00, 0x00, 0x40, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,  
  32              0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 0x01, 0x00, 0x00, 0x00,  
  33              0x00, 0x00, 0xFA, 0x36, 0xFF, 0xBC, 0x30, 0x8E, 0x00, 0x05, 0xFB, 0xF0, 0xFF, 0xD9, 0x5B, 0xC8,  
  34              0xFF, 0xD0, 0x9A, 0xBE, 0x00, 0x00, 0x10, 0xA9, 0xFF, 0xF4, 0x1E, 0xB2, 0x00, 0xCE, 0xBB, 0xF7,  
  35              0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x04, 0x00, 0x02, 0x00, 0x02, 0x02, 0x00, 0x00, 0x0C,  
  36              0xFF, 0xC2, 0x80, 0x00, 0x00, 0x01, 0x80, 0x00, 0x00, 0xCF, 0x80, 0x00, 0x40, 0x00, 0x00, 0x00,  
  37              0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x06, 0x00, 0x00, 0x00, 0x00, 0x14,  
  38              0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,  
  39              0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,  
  40              0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,  
  41              0x00, 0x00, 0x00, 0x00, 0x03, 0x3F, 0x68, 0xB6, 0x79, 0x35, 0x28, 0xBC, 0xC6, 0x7E, 0xD1, 0x6C,  
  42              0x80, 0x00, 0x00, 0x00, 0x40, 0x00, 0x00, 0x00, 0x00, 0x00, 0xB2, 0x6A, 0x00, 0x00, 0x00, 0x00,  
  43              0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x3F, 0xF0, 0x00, 0x00, 0x00, 0x30,  
  44              0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,  
  45              0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,  
  46              0x00, 0x00, 0x25, 0x4D, 0x00, 0x2F, 0x70, 0x6D, 0x00, 0x00, 0x05, 0xAE, 0x00, 0x0C, 0x02, 0xD0,  
  47              // bank 2, 256 bytes  
  48              0x00, 0x00, 0x00, 0x00, 0x00, 0x65, 0x00, 0x54, 0xFF, 0xEF, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,  
  49              0x00, 0x00, 0x01, 0x00, 0x00, 0x44, 0x00, 0x00, 0x00, 0x00, 0x0C, 0x00, 0x00, 0x00, 0x01, 0x00,  
  50              0x00, 0x00, 0x00, 0x00, 0x00, 0x65, 0x00, 0x00, 0x00, 0x54, 0x00, 0x00, 0xFF, 0xEF, 0x00, 0x00,  
  51              0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,  
  52              0x40, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,  
  53              0x40, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,  
  54              0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x02, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,  
  55              0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,  
C51 COMPILER V9.52.0.0   DMPTEXT                                                           08/29/2017 15:52:11 PAGE 2   

  56              0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,  
  57              0x00, 0x1B, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,  
  58              0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,  
  59              0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x40, 0x00, 0x00, 0x00,  
  60              0x00, 0x1B, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,  
  61              0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,  
  62              0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,  
  63              0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,  
  64              // bank 3, 256 bytes  
  65              0xD8, 0xDC, 0xBA, 0xA2, 0xF1, 0xDE, 0xB2, 0xB8, 0xB4, 0xA8, 0x81, 0x91, 0xF7, 0x4A, 0x90, 0x7F,  
  66              0x91, 0x6A, 0xF3, 0xF9, 0xDB, 0xA8, 0xF9, 0xB0, 0xBA, 0xA0, 0x80, 0xF2, 0xCE, 0x81, 0xF3, 0xC2,  
  67              0xF1, 0xC1, 0xF2, 0xC3, 0xF3, 0xCC, 0xA2, 0xB2, 0x80, 0xF1, 0xC6, 0xD8, 0x80, 0xBA, 0xA7, 0xDF,  
  68              0xDF, 0xDF, 0xF2, 0xA7, 0xC3, 0xCB, 0xC5, 0xB6, 0xF0, 0x87, 0xA2, 0x94, 0x24, 0x48, 0x70, 0x3C,  
  69              0x95, 0x40, 0x68, 0x34, 0x58, 0x9B, 0x78, 0xA2, 0xF1, 0x83, 0x92, 0x2D, 0x55, 0x7D, 0xD8, 0xB1,  
  70              0xB4, 0xB8, 0xA1, 0xD0, 0x91, 0x80, 0xF2, 0x70, 0xF3, 0x70, 0xF2, 0x7C, 0x80, 0xA8, 0xF1, 0x01,  
  71              0xB0, 0x98, 0x87, 0xD9, 0x43, 0xD8, 0x86, 0xC9, 0x88, 0xBA, 0xA1, 0xF2, 0x0E, 0xB8, 0x97, 0x80,  
  72              0xF1, 0xA9, 0xDF, 0xDF, 0xDF, 0xAA, 0xDF, 0xDF, 0xDF, 0xF2, 0xAA, 0xC5, 0xCD, 0xC7, 0xA9, 0x0C,  
  73              0xC9, 0x2C, 0x97, 0x97, 0x97, 0x97, 0xF1, 0xA9, 0x89, 0x26, 0x46, 0x66, 0xB0, 0xB4, 0xBA, 0x80,  
  74              0xAC, 0xDE, 0xF2, 0xCA, 0xF1, 0xB2, 0x8C, 0x02, 0xA9, 0xB6, 0x98, 0x00, 0x89, 0x0E, 0x16, 0x1E,  
  75              0xB8, 0xA9, 0xB4, 0x99, 0x2C, 0x54, 0x7C, 0xB0, 0x8A, 0xA8, 0x96, 0x36, 0x56, 0x76, 0xF1, 0xB9,  
  76              0xAF, 0xB4, 0xB0, 0x83, 0xC0, 0xB8, 0xA8, 0x97, 0x11, 0xB1, 0x8F, 0x98, 0xB9, 0xAF, 0xF0, 0x24,  
  77              0x08, 0x44, 0x10, 0x64, 0x18, 0xF1, 0xA3, 0x29, 0x55, 0x7D, 0xAF, 0x83, 0xB5, 0x93, 0xAF, 0xF0,  
  78              0x00, 0x28, 0x50, 0xF1, 0xA3, 0x86, 0x9F, 0x61, 0xA6, 0xDA, 0xDE, 0xDF, 0xD9, 0xFA, 0xA3, 0x86,  
  79              0x96, 0xDB, 0x31, 0xA6, 0xD9, 0xF8, 0xDF, 0xBA, 0xA6, 0x8F, 0xC2, 0xC5, 0xC7, 0xB2, 0x8C, 0xC1,  
  80              0xB8, 0xA2, 0xDF, 0xDF, 0xDF, 0xA3, 0xDF, 0xDF, 0xDF, 0xD8, 0xD8, 0xF1, 0xB8, 0xA8, 0xB2, 0x86,  
  81              // bank 4, 256 bytes  
  82              0xB4, 0x98, 0x0D, 0x35, 0x5D, 0xB8, 0xAA, 0x98, 0xB0, 0x87, 0x2D, 0x35, 0x3D, 0xB2, 0xB6, 0xBA,  
  83              0xAF, 0x8C, 0x96, 0x19, 0x8F, 0x9F, 0xA7, 0x0E, 0x16, 0x1E, 0xB4, 0x9A, 0xB8, 0xAA, 0x87, 0x2C,  
  84              0x54, 0x7C, 0xB9, 0xA3, 0xDE, 0xDF, 0xDF, 0xA3, 0xB1, 0x80, 0xF2, 0xC4, 0xCD, 0xC9, 0xF1, 0xB8,  
  85              0xA9, 0xB4, 0x99, 0x83, 0x0D, 0x35, 0x5D, 0x89, 0xB9, 0xA3, 0x2D, 0x55, 0x7D, 0xB5, 0x93, 0xA3,  
  86              0x0E, 0x16, 0x1E, 0xA9, 0x2C, 0x54, 0x7C, 0xB8, 0xB4, 0xB0, 0xF1, 0x97, 0x83, 0xA8, 0x11, 0x84,  
  87              0xA5, 0x09, 0x98, 0xA3, 0x83, 0xF0, 0xDA, 0x24, 0x08, 0x44, 0x10, 0x64, 0x18, 0xD8, 0xF1, 0xA5,  
  88              0x29, 0x55, 0x7D, 0xA5, 0x85, 0x95, 0x02, 0x1A, 0x2E, 0x3A, 0x56, 0x5A, 0x40, 0x48, 0xF9, 0xF3,  
  89              0xA3, 0xD9, 0xF8, 0xF0, 0x98, 0x83, 0x24, 0x08, 0x44, 0x10, 0x64, 0x18, 0x97, 0x82, 0xA8, 0xF1,  
  90              0x11, 0xF0, 0x98, 0xA2, 0x24, 0x08, 0x44, 0x10, 0x64, 0x18, 0xDA, 0xF3, 0xDE, 0xD8, 0x83, 0xA5,  
  91              0x94, 0x01, 0xD9, 0xA3, 0x02, 0xF1, 0xA2, 0xC3, 0xC5, 0xC7, 0xD8, 0xF1, 0x84, 0x92, 0xA2, 0x4D,  
  92              0xDA, 0x2A, 0xD8, 0x48, 0x69, 0xD9, 0x2A, 0xD8, 0x68, 0x55, 0xDA, 0x32, 0xD8, 0x50, 0x71, 0xD9,  
  93              0x32, 0xD8, 0x70, 0x5D, 0xDA, 0x3A, 0xD8, 0x58, 0x79, 0xD9, 0x3A, 0xD8, 0x78, 0x93, 0xA3, 0x4D,  
  94              0xDA, 0x2A, 0xD8, 0x48, 0x69, 0xD9, 0x2A, 0xD8, 0x68, 0x55, 0xDA, 0x32, 0xD8, 0x50, 0x71, 0xD9,  
  95              0x32, 0xD8, 0x70, 0x5D, 0xDA, 0x3A, 0xD8, 0x58, 0x79, 0xD9, 0x3A, 0xD8, 0x78, 0xA8, 0x8A, 0x9A,  
  96              0xF0, 0x28, 0x50, 0x78, 0x9E, 0xF3, 0x88, 0x18, 0xF1, 0x9F, 0x1D, 0x98, 0xA8, 0xD9, 0x08, 0xD8,  
  97              0xC8, 0x9F, 0x12, 0x9E, 0xF3, 0x15, 0xA8, 0xDA, 0x12, 0x10, 0xD8, 0xF1, 0xAF, 0xC8, 0x97, 0x87,  
  98              // bank 5, 256 bytes  
  99              0x34, 0xB5, 0xB9, 0x94, 0xA4, 0x21, 0xF3, 0xD9, 0x22, 0xD8, 0xF2, 0x2D, 0xF3, 0xD9, 0x2A, 0xD8,  
 100              0xF2, 0x35, 0xF3, 0xD9, 0x32, 0xD8, 0x81, 0xA4, 0x60, 0x60, 0x61, 0xD9, 0x61, 0xD8, 0x6C, 0x68,  
 101              0x69, 0xD9, 0x69, 0xD8, 0x74, 0x70, 0x71, 0xD9, 0x71, 0xD8, 0xB1, 0xA3, 0x84, 0x19, 0x3D, 0x5D,  
 102              0xA3, 0x83, 0x1A, 0x3E, 0x5E, 0x93, 0x10, 0x30, 0x81, 0x10, 0x11, 0xB8, 0xB0, 0xAF, 0x8F, 0x94,  
 103              0xF2, 0xDA, 0x3E, 0xD8, 0xB4, 0x9A, 0xA8, 0x87, 0x29, 0xDA, 0xF8, 0xD8, 0x87, 0x9A, 0x35, 0xDA,  
 104              0xF8, 0xD8, 0x87, 0x9A, 0x3D, 0xDA, 0xF8, 0xD8, 0xB1, 0xB9, 0xA4, 0x98, 0x85, 0x02, 0x2E, 0x56,  
 105              0xA5, 0x81, 0x00, 0x0C, 0x14, 0xA3, 0x97, 0xB0, 0x8A, 0xF1, 0x2D, 0xD9, 0x28, 0xD8, 0x4D, 0xD9,  
 106              0x48, 0xD8, 0x6D, 0xD9, 0x68, 0xD8, 0xB1, 0x84, 0x0D, 0xDA, 0x0E, 0xD8, 0xA3, 0x29, 0x83, 0xDA,  
 107              0x2C, 0x0E, 0xD8, 0xA3, 0x84, 0x49, 0x83, 0xDA, 0x2C, 0x4C, 0x0E, 0xD8, 0xB8, 0xB0, 0xA8, 0x8A,  
 108              0x9A, 0xF5, 0x20, 0xAA, 0xDA, 0xDF, 0xD8, 0xA8, 0x40, 0xAA, 0xD0, 0xDA, 0xDE, 0xD8, 0xA8, 0x60,  
 109              0xAA, 0xDA, 0xD0, 0xDF, 0xD8, 0xF1, 0x97, 0x86, 0xA8, 0x31, 0x9B, 0x06, 0x99, 0x07, 0xAB, 0x97,  
 110              0x28, 0x88, 0x9B, 0xF0, 0x0C, 0x20, 0x14, 0x40, 0xB8, 0xB0, 0xB4, 0xA8, 0x8C, 0x9C, 0xF0, 0x04,  
 111              0x28, 0x51, 0x79, 0x1D, 0x30, 0x14, 0x38, 0xB2, 0x82, 0xAB, 0xD0, 0x98, 0x2C, 0x50, 0x50, 0x78,  
 112              0x78, 0x9B, 0xF1, 0x1A, 0xB0, 0xF0, 0x8A, 0x9C, 0xA8, 0x29, 0x51, 0x79, 0x8B, 0x29, 0x51, 0x79,  
 113              0x8A, 0x24, 0x70, 0x59, 0x8B, 0x20, 0x58, 0x71, 0x8A, 0x44, 0x69, 0x38, 0x8B, 0x39, 0x40, 0x68,  
 114              0x8A, 0x64, 0x48, 0x31, 0x8B, 0x30, 0x49, 0x60, 0xA5, 0x88, 0x20, 0x09, 0x71, 0x58, 0x44, 0x68,  
 115              // bank 6, 256 bytes  
 116              0x11, 0x39, 0x64, 0x49, 0x30, 0x19, 0xF1, 0xAC, 0x00, 0x2C, 0x54, 0x7C, 0xF0, 0x8C, 0xA8, 0x04,  
 117              0x28, 0x50, 0x78, 0xF1, 0x88, 0x97, 0x26, 0xA8, 0x59, 0x98, 0xAC, 0x8C, 0x02, 0x26, 0x46, 0x66,  
C51 COMPILER V9.52.0.0   DMPTEXT                                                           08/29/2017 15:52:11 PAGE 3   

 118              0xF0, 0x89, 0x9C, 0xA8, 0x29, 0x51, 0x79, 0x24, 0x70, 0x59, 0x44, 0x69, 0x38, 0x64, 0x48, 0x31,  
 119              0xA9, 0x88, 0x09, 0x20, 0x59, 0x70, 0xAB, 0x11, 0x38, 0x40, 0x69, 0xA8, 0x19, 0x31, 0x48, 0x60,  
 120              0x8C, 0xA8, 0x3C, 0x41, 0x5C, 0x20, 0x7C, 0x00, 0xF1, 0x87, 0x98, 0x19, 0x86, 0xA8, 0x6E, 0x76,  
 121              0x7E, 0xA9, 0x99, 0x88, 0x2D, 0x55, 0x7D, 0x9E, 0xB9, 0xA3, 0x8A, 0x22, 0x8A, 0x6E, 0x8A, 0x56,  
 122              0x8A, 0x5E, 0x9F, 0xB1, 0x83, 0x06, 0x26, 0x46, 0x66, 0x0E, 0x2E, 0x4E, 0x6E, 0x9D, 0xB8, 0xAD,  
 123              0x00, 0x2C, 0x54, 0x7C, 0xF2, 0xB1, 0x8C, 0xB4, 0x99, 0xB9, 0xA3, 0x2D, 0x55, 0x7D, 0x81, 0x91,  
 124              0xAC, 0x38, 0xAD, 0x3A, 0xB5, 0x83, 0x91, 0xAC, 0x2D, 0xD9, 0x28, 0xD8, 0x4D, 0xD9, 0x48, 0xD8,  
 125              0x6D, 0xD9, 0x68, 0xD8, 0x8C, 0x9D, 0xAE, 0x29, 0xD9, 0x04, 0xAE, 0xD8, 0x51, 0xD9, 0x04, 0xAE,  
 126              0xD8, 0x79, 0xD9, 0x04, 0xD8, 0x81, 0xF3, 0x9D, 0xAD, 0x00, 0x8D, 0xAE, 0x19, 0x81, 0xAD, 0xD9,  
 127              0x01, 0xD8, 0xF2, 0xAE, 0xDA, 0x26, 0xD8, 0x8E, 0x91, 0x29, 0x83, 0xA7, 0xD9, 0xAD, 0xAD, 0xAD,  
 128              0xAD, 0xF3, 0x2A, 0xD8, 0xD8, 0xF1, 0xB0, 0xAC, 0x89, 0x91, 0x3E, 0x5E, 0x76, 0xF3, 0xAC, 0x2E,  
 129              0x2E, 0xF1, 0xB1, 0x8C, 0x5A, 0x9C, 0xAC, 0x2C, 0x28, 0x28, 0x28, 0x9C, 0xAC, 0x30, 0x18, 0xA8,  
 130              0x98, 0x81, 0x28, 0x34, 0x3C, 0x97, 0x24, 0xA7, 0x28, 0x34, 0x3C, 0x9C, 0x24, 0xF2, 0xB0, 0x89,  
 131              0xAC, 0x91, 0x2C, 0x4C, 0x6C, 0x8A, 0x9B, 0x2D, 0xD9, 0xD8, 0xD8, 0x51, 0xD9, 0xD8, 0xD8, 0x79,  
 132              // bank 7, 138 bytes (remainder)  
 133              0xD9, 0xD8, 0xD8, 0xF1, 0x9E, 0x88, 0xA3, 0x31, 0xDA, 0xD8, 0xD8, 0x91, 0x2D, 0xD9, 0x28, 0xD8,  
 134              0x4D, 0xD9, 0x48, 0xD8, 0x6D, 0xD9, 0x68, 0xD8, 0xB1, 0x83, 0x93, 0x35, 0x3D, 0x80, 0x25, 0xDA,  
 135              0xD8, 0xD8, 0x85, 0x69, 0xDA, 0xD8, 0xD8, 0xB4, 0x93, 0x81, 0xA3, 0x28, 0x34, 0x3C, 0xF3, 0xAB,  
 136              0x8B, 0xF8, 0xA3, 0x91, 0xB6, 0x09, 0xB4, 0xD9, 0xAB, 0xDE, 0xFA, 0xB0, 0x87, 0x9C, 0xB9, 0xA3,  
 137              0xDD, 0xF1, 0xA3, 0xA3, 0xA3, 0xA3, 0x95, 0xF1, 0xA3, 0xA3, 0xA3, 0x9D, 0xF1, 0xA3, 0xA3, 0xA3,  
 138              0xA3, 0xF2, 0xA3, 0xB4, 0x90, 0x80, 0xF2, 0xA3, 0xA3, 0xA3, 0xA3, 0xA3, 0xA3, 0xA3, 0xA3, 0xA3,  
 139              0xA3, 0xB2, 0xA3, 0xA3, 0xA3, 0xA3, 0xA3, 0xA3, 0xB0, 0x87, 0xB5, 0x99, 0xF1, 0xA3, 0xA3, 0xA3,  
 140              0x98, 0xF1, 0xA3, 0xA3, 0xA3, 0xA3, 0x97, 0xA3, 0xA3, 0xA3, 0xA3, 0xF3, 0x9B, 0xA3, 0xA3, 0xDC,  
 141              0xB9, 0xA7, 0xF1, 0x26, 0x26, 0x26, 0xD8, 0xD8, 0xFF  
 142          };  
 143          code unsigned char dmpcfgupddata[192] = {  
 144          //  dmp config   
 145          //  BANK    OFFSET  LENGTH  [DATA]  
 146              0x03,   0x7B,   0x03,   0x4C, 0xCD, 0x6C,           
 147              0x03,   0xAB,   0x03,   0x36, 0x56, 0x76,           
 148              0x00,   0x68,   0x04,   0x02, 0xCB, 0x47, 0xA2,     
 149              0x02,   0x18,   0x04,   0x00, 0x05, 0x8B, 0xC1,     
 150              0x01,   0x0C,   0x04,   0x00, 0x00, 0x00, 0x00,     
 151              0x03,   0x7F,   0x06,   0x0C, 0xC9, 0x2C, 0x97, 0x97, 0x97,   
 152              0x03,   0x89,   0x03,   0x26, 0x46, 0x66,           
 153              0x00,   0x6C,   0x02,   0x20, 0x00,                 
 154              0x02,   0x40,   0x04,   0x00, 0x00, 0x00, 0x00,     
 155              0x02,   0x44,   0x04,   0x00, 0x00, 0x00, 0x00,     
 156              0x02,   0x48,   0x04,   0x00, 0x00, 0x00, 0x00,     
 157              0x02,   0x4C,   0x04,   0x00, 0x00, 0x00, 0x00,     
 158              0x02,   0x50,   0x04,   0x00, 0x00, 0x00, 0x00,     
 159              0x02,   0x54,   0x04,   0x00, 0x00, 0x00, 0x00,    
 160              0x02,   0x58,   0x04,   0x00, 0x00, 0x00, 0x00,    
 161              0x02,   0x5C,   0x04,   0x00, 0x00, 0x00, 0x00,    
 162              0x02,   0xBC,   0x04,   0x00, 0x00, 0x00, 0x00,     
 163              0x01,   0xEC,   0x04,   0x00, 0x00, 0x40, 0x00,    
 164              0x03,   0x7F,   0x06,   0x0C, 0xC9, 0x2C, 0x97, 0x97, 0x97,  
 165              0x04,   0x02,   0x03,   0x0D, 0x35, 0x5D,           
 166              0x04,   0x09,   0x04,   0x87, 0x2D, 0x35, 0x3D,     
 167              0x00,   0xA3,   0x01,   0x00,                      
 168              0x00,   0x00,   0x00,   0x01,   //这里是开启DMP的特殊中断的  
 169              //原程序中此行代码为(这里不一定错)  
 170              //0x00,   0x00,   0x00,   0x01,  即LENGTH=0x00，有错  
 171                    
 172              0x07,   0x86,   0x01,   0xFE,                       
 173              0x07,   0x41,   0x05,   0xF1, 0x20, 0x28, 0x30, 0x38,   
 174              0x07,   0x7E,   0x01,   0x30,                     
 175              0x07,   0x46,   0x01,   0x9A,                      
 176              0x07,   0x47,   0x04,   0xF1, 0x28, 0x30, 0x38,     
 177              0x07,   0x6C,   0x04,   0xF1, 0x28, 0x30, 0x38,    
 178              0x02,   0x16,   0x02,   0x00, 0x01,                
 179          /* 上行最后一个数据调整FIFO rate :0x01=100HZ,0x02=66HZ,0x03=50HZ ,0x04=40HZ,0x05=33.33HZ,  
C51 COMPILER V9.52.0.0   DMPTEXT                                                           08/29/2017 15:52:11 PAGE 4   

 180          // 可从 datasheet 公式推算 
 181          //dmp updates 
 182              0x01,   0xB2,   0x02,   0xFF, 0xFF, 
 183              0x01,   0x90,   0x04,   0x09, 0x23, 0xA1, 0x35, 
 184              0x01,   0x6A,   0x02,   0x06, 0x00, 
 185              0x01,   0x60,   0x08,   0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
 186              0x00,   0x60,   0x04,   0x40, 0x00, 0x00, 0x00, 
 187              0x01,   0x62,   0x02,   0x00, 0x00, 
 188              0x00,   0x60,   0x04,   0x00, 0x40, 0x00, 0x00*/  
 189          };  
 190          code unsigned char dmpUpdates[47]={  
 191                
 192              0x01,   0xB2,   0x02,   0xFF, 0xFF,  
 193              0x01,   0x90,   0x04,   0x09, 0x23, 0xA1, 0x35,  
 194              0x01,   0x6A,   0x02,   0x06, 0x00,  
 195              0x01,   0x60,   0x08,   0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,  
 196              0x00,   0x60,   0x04,   0x40, 0x00, 0x00, 0x00,  
 197              0x01,   0x62,   0x02,   0x00, 0x00,  
 198              0x00,   0x60,   0x04,   0x00, 0x40, 0x00, 0x00  
 199                
 200          };  
 201          
 202          
 203          void DelayUs2x(unsigned char t) //延时1  
 204          {     
 205   1       while(--t);  
 206   1      }  
 207            
 208          void DelayMs(unsigned char t)   //延时2  
 209          {  
 210   1             
 211   1       while(t--)  
 212   1       {  
 213   2           //大致延时1mS  
 214   2           DelayUs2x(245);  
 215   2           DelayUs2x(245);  
 216   2       }  
 217   1      }  
 218          
 219          
 220          
 221          
 222           /* 
 223             加载 DMP代码到 
 224             返回值  (1=成功,0=失败) 
 225           */  
 226          void loadfirmware(void)      
 227          {  
 228   1        unsigned int datanum=0;   //DMP固件写入标志位  
 229   1        unsigned char ye,i,j;  
 230   1        unsigned char bank=0; //段（256个数据一段）  
 231   1        unsigned char addr=0;   
 232   1        
 233   1          for(;bank<8;bank++)  
 234   1          {  
 235   2              if(bank == 7)   //这里的作用就是区分最后一段数据  
 236   2                  i = 8;  
 237   2              else  
 238   2                  i = 16;  
 239   2              for(ye=0;ye<i;ye++)  
 240   2              {  
 241   3                  send_I2c(0x6d,bank);  
C51 COMPILER V9.52.0.0   DMPTEXT                                                           08/29/2017 15:52:11 PAGE 5   

 242   3                  send_I2c(0x6e,addr);  
 243   3                  start_I2c();    //起始信号  
 244   3                  send_bite(SlaveAddressW);    //设备地址+写信号  
 245   3                  Wake_I2c();
 246   3                  send_bite(0x6f);    //设备内部地址  
 247   3                  for(j=0;j<16;j++)  
 248   3                  {  
 249   4                      send_bite(dmpmemorydata[datanum++]);    //写入DMP的数据  
 250   4                      Wake_I2c();
 251   4               //       if(ack) return 0;   
 252   4                  }  
 253   3                  addr += 16;  
 254   3                  stop_I2c();    //停止信号  
 255   3              }  
 256   2          }  
 257   1          send_I2c(0x6d,7);  
 258   1          send_I2c(0x6e,addr);  
 259   1          start_I2c();    //起始信号  
 260   1          send_bite(SlaveAddressW);    //设备地址+写信号  
 261   1          Wake_I2c();
 262   1          send_bite(0x6f);    //设备内部地址  
 263   1          Wake_I2c();
 264   1          for(i=0;i<9;i++)  
 265   1          {  
 266   2              send_bite(dmpmemorydata[datanum++]);    //写入DMP的数据  
 267   2              Wake_I2c();
 268   2         //     if(ack) return 0;  
 269   2          }  
 270   1          stop_I2c();    //停止信号  
 271   1       //   return 1;  
 272   1      }  
 273          
 274          void loadcfgupd(void)  //DMP设置  
 275          {  
 276   1        unsigned char line;   //一共需要写入30条设置数据  
 277   1        unsigned char bank;   //页  
 278   1        unsigned char datacounts=0;   //DMP设置数据标志位  
 279   1        unsigned char bytes2write;    //数据长度。  
 280   1        unsigned char offset; //偏移地址  
 281   1        unsigned char writingcounts;  //数据写入标志与bytes2write一同使用  
 282   1        unsigned char special;  
 283   1             
 284   1        for (line=0;line<30;line++)  
 285   1        {  
 286   2          bank=dmpcfgupddata[datacounts++];  
 287   2          offset=dmpcfgupddata[datacounts++];  
 288   2          bytes2write=dmpcfgupddata[datacounts++];  
 289   2          send_I2c(0x6d,bank);  
 290   2          send_I2c(0x6e,offset);  
 291   2          start_I2c();    //起始信号  
 292   2          send_bite(SlaveAddressW);    //设备地址+写信号  
 293   2          Wake_I2c();
 294   2          send_bite(0x6f);    //设备内部地址  
 295   2          Wake_I2c();
 296   2          for(writingcounts=0;writingcounts<bytes2write;writingcounts++)  
 297   2          {  
 298   3              send_bite(dmpcfgupddata[datacounts++]); //写入DMP配置数据  
 299   3              Wake_I2c();
 300   3         //         if(ack) return 0;  
 301   3          }  
 302   2          if(0 == bytes2write)  
 303   2          {  
C51 COMPILER V9.52.0.0   DMPTEXT                                                           08/29/2017 15:52:11 PAGE 6   

 304   3              special=dmpcfgupddata[datacounts++];  
 305   3              if(0x01 == special)  
 306   3                  {  
 307   4                      //设置零运动中断启用（真）;  
 308   4                //设置FIFO缓冲区溢出启用（真）;  
 309   4                //设置DMP启用（真）;  
 310   4                      send_I2c(0x38,0x32);  
 311   4                  }  
 312   3        //      else  
 313   3         //         return 0;  
 314   3          }  
 315   2        }  
 316   1        stop_I2c();  //停止信号  
 317   1       //   return 1;  
 318   1      }  
 319          /*最后更新DMP*/  
 320          void xdmpUpdates(unsigned char datacounts)  
 321          {  
 322   1          unsigned char writingcounts,bank,offset,bytes2write;  
 323   1          bank=dmpUpdates[datacounts++];  
 324   1        offset=dmpUpdates[datacounts++];  
 325   1        bytes2write=dmpUpdates[datacounts++];  
 326   1        send_I2c(0x6d,bank);  
 327   1        send_I2c(0x6e,offset);  
 328   1        start_I2c();  //起始信号  
 329   1        send_bite(SlaveAddressW);    //设备地址+写信号  
 330   1        Wake_I2c();
 331   1        send_bite(0x6f);    //设备内部地址  
 332   1        Wake_I2c();
 333   1          for(writingcounts=0;writingcounts<bytes2write;writingcounts++)  
 334   1          {  
 335   2              send_bite(dmpUpdates[datacounts++]);    //写入DMP配置数据  
 336   2              Wake_I2c();
 337   2        //          if(ack) return 0;  
 338   2          }  
 339   1          stop_I2c();    //停止信号  
 340   1       //   return 0;  
 341   1      }  
 342          /*读取 FIFO 计数*/  
 343          unsigned int getFIFOCount()  
 344          {  
 345   1          unsigned char i[2];  
 346   1          recs_I2c(0x72,2,i);  
 347   1          return ((i[0]<<8)+i[1]);  
 348   1      }  
 349          /*FIFO数据读取 
 350          参数 *Data    存储数据的地址 
 351          返回值 (1=读取成功,0读取失败) 
 352          */  
 353          void readdmp(unsigned char *Data)  
 354          {  
 355   1       recs_I2c(0x74,42,Data);  
 356   1      }  
 357          
 358          
 359          void dmpInitialize(void)  
 360          {  
 361   1          unsigned char hwRevision,otpValid,mpuIntStatus/*fifoBuffer[128]*/;  
 362   1          unsigned char xgOffsetTC,ygOffsetTC,zgOffsetTC;  
 363   1          unsigned int fifoCount;  
 364   1          writeBit(0x6B,7,1); //复位 MPU6050  
 365   1          DelayMs(50);
C51 COMPILER V9.52.0.0   DMPTEXT                                                           08/29/2017 15:52:11 PAGE 7   

 366   1          writeBit(0x6B,6,0); //禁止睡眠模式  
 367   1          send_I2c(0x6D,0x70);    //写入一个字节数据到0x6d寄存器(选择用户 bank)  
 368   1          send_I2c(0x6E,0x06);    //写入一个字节数据到0x6e寄存器(选择存储字节)  
 369   1          recs_I2c(0x6F,1,&hwRevision);  //读取  
 370   1          send_I2c(0x6D,0);   //重置内存 bank 选择  
 371   1          readBit(0x00,0,&otpValid);  //读取 OTP bank 有效标志  
 372   1          readBits(0x00,6,6,&xgOffsetTC); //读陀螺偏置TC值 X  
 373   1          readBits(0x01,6,6,&ygOffsetTC); //读陀螺偏置TC值 Y)  
 374   1          readBits(0x02,6,6,&zgOffsetTC); //读陀螺偏置TC值 Z  
 375   1          send_I2c(0x25,0x7f);    //设置从0地址 0x7  
 376   1          writeBit(0x6A,5,0); //禁用I2C主模式  
 377   1          send_I2c(0x25,0x68);    //这里可能要改。还没有弄明白这里  
 378   1          writeBit(0x6A,1,1); //I2C总线主控复位  
 379   1          DelayMs(20);  
 380   1          loadfirmware();   //加载 DMP代码到内存  
 381   1          loadcfgupd();  //配制DMP  
 382   1          writeBits(0x6B,2,3,0x03);   //设置时钟脉冲源Z陀螺  
 383   1          send_I2c(0x38,0x12);    //设置DMP和FIFO_OFLOW启用中断  
 384   1          send_I2c(0x19,4);   //设置采样率为200 hz  (1khz / (1 + 4) = 200 Hz)  
 385   1          writeBits(0x1A,5,3,0x1);    //设置外部帧同步TEMP_OUT_L[0]  
 386   1          writeBits(0x1A,2,3,0x03);   //设置DLPF带宽42赫兹  
 387   1          writeBits(0x1B,4,2,0x03);   //陀螺灵敏度设置为+ / - 2000 deg/sec  
 388   1          send_I2c(0x70,0x03);    //设置DMP配置字节（功能未知）  
 389   1          send_I2c(0x71,0x00);    //设置DMP配置字节（功能未知）  
 390   1          writeBit(0x00,0,0); //清除OTP Bank 标志  
 391   1          writeBits(0x00,6,6,xgOffsetTC); //设置X 陀螺抵消TCs之前的值  
 392   1          writeBits(0x01,6,6,ygOffsetTC); //设置Y 陀螺抵消TCs之前的值  
 393   1          writeBits(0x02,6,6,zgOffsetTC); //设置Z 陀螺抵消TCs之前的值  
 394   1          xdmpUpdates(0); //最后更新1/7(函数未知)dmpUpdates数组第一行  
 395   1          xdmpUpdates(5); //最后更新2/7(函数未知)dmpUpdates数组第二行  
 396   1          writeBit(0x6A,2,1); //复位 FIFO  
 397   1          fifoCount = getFIFOCount(); //读取 FIFO 计数  
 398   1          //readdmp(fifoCount,fifoBuffer);    //读取FIFO里的数据  
 399   1          writeBit(0x6A,2,1); //复位 FIFO  
 400   1            
 401   1          send_I2c(0x1F,2);   //运动检测阈值设置为2  
 402   1          send_I2c(0x21,156); //零运动检测阈值为156  
 403   1          send_I2c(0x20,80);  //设置运动检测持续时间至80  
 404   1          send_I2c(0x22,0);   //设置零运动检测时间0  
 405   1          writeBit(0x6A,2,1); //复位 FIFO  
 406   1          writeBit(0x6A,6,1); //使能 FIFO  
 407   1          writeBit(0x6A,7,1); //使能 DMP  
 408   1          writeBit(0x6A,3,1); //复位 DMP  
 409   1          xdmpUpdates(12);    //最后更新3/7(函数未知)dmpUpdates数组第三行  
 410   1          xdmpUpdates(17);    //最后更新4/7(函数未知)dmpUpdates数组第四行  
 411   1          xdmpUpdates(28);    //最后更新5/7(函数未知)dmpUpdates数组第五行  
 412   1          while((fifoCount = getFIFOCount()) < 3); //等待 FIFO 计数 > 2  
 413   1          writeBit(0x6A,2,1); //复位 FIFO  
 414   1          //readdmp(fifoCount,fifoBuffer);    //读取FIFO里的数据  
 415   1          recs_I2c(0x3A,1,&mpuIntStatus);    //读取中断状态  
 416   1          xdmpUpdates(35);    //最后更新6/7(函数未知)dmpUpdates数组第六行  
 417   1          while((fifoCount = getFIFOCount()) < 3); //等待 FIFO 计数 > 2  
 418   1          writeBit(0x6A,2,1); //复位 FIFO  
 419   1          //readdmp(fifoCount,fifoBuffer);    //读取FIFO里的数据  
 420   1          recs_I2c(0x3A,1,&mpuIntStatus);    //读取中断状态  
 421   1          xdmpUpdates(40);    //最后更新7/7(函数未知)dmpUpdates数组第七行  
 422   1          writeBit(0x6A,7,0); //禁用DMP(稍后您打开它)  
 423   1          writeBit(0x6A,2,1); //复位 FIFO  
 424   1          recs_I2c(0x3A,1,&mpuIntStatus);  
 425   1          //星期六 (2014/06/28)   
 426   1      }  
 427          /*********compute quaters *************/
C51 COMPILER V9.52.0.0   DMPTEXT                                                           08/29/2017 15:52:11 PAGE 8   

 428          
 429          void compute (void)
 430          {
 431   1        unsigned char iii,qq[4],q[4],pitch,roll,yaw,norm,zd;
 432   1            iii=getFIFOCount();//读取FIFO计数  
 433   1          recs_I2c(0x3A,1,&zd);  //读取中断状态  
 434   1          if((zd & 0x10)||iii==1024)    //判断FIFO是否溢出  
 435   1          {  
 436   2              writeBit(0x6A,2,1); //复位 FIFO  
 437   2          }  
 438   1          else if (zd & 0x02)  
 439   1          {  
 440   2              while(iii<42) iii=getFIFOCount();  
 441   2              readdmp(dmpdatas);  //读取FIFO数据(四元数+其他的数据)  
 442   2              qq[0]=(dmpdatas[0]);  
 443   2              qq[1]=(dmpdatas[2]);  
 444   2              qq[2]=(dmpdatas[4]);   
 445   2              qq[3]=(dmpdatas[6]);   
 446   2              norm = sqrt(qq[0]*qq[0] + qq[1]*qq[1] + qq[2]*qq[2] + qq[3]*qq[3]);
 447   2              q[0] = qq[0] * norm;
 448   2              q[1] = qq[1] * norm;
 449   2              q[2] = qq[2] * norm;
 450   2              q[3] = qq[3] * norm;
 451   2        
 452   2              roll = (atan2(2.0*(q[0]*q[1] + q[2]*q[3]),
 453   2                               1 - 2.0*(q[1]*q[1] + q[2]*q[2])))* 180/M_PI;
 454   2         // we let safe_asin() handle the singularities near 90/-90 in pitch
 455   2              pitch = asin(2.0*(q[0]*q[2] - q[3]*q[1]))* 180/M_PI;
 456   2        //??:??????,?????
 457   2              yaw = -atan2(2.0*(q[0]*q[3] + q[1]*q[2]),
 458   2                             1 - 2.0*(q[2]*q[2] + q[3]*q[3]))* 180/M_PI;
 459   2          } 
 460   1      }


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =   1803    ----
   CONSTANT SIZE    =   2168    ----
   XDATA SIZE       =   ----      39
   PDATA SIZE       =   ----    ----
   DATA SIZE        =   ----    ----
   IDATA SIZE       =   ----    ----
   BIT SIZE         =   ----    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
